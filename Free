local Fusion = require(game.ReplicatedStorage.Fusion)

local New = Fusion.New
local Value = Fusion.Value
local Computed = Fusion.Computed
local OnEvent = Fusion.OnEvent

local UI = {}

local selectedTab = Value("Catching")

local function createTabButton(tabName)
    return New "TextButton" {
        Name = tabName .. "Tab",
        Text = tabName,
        Size = UDim2.new(0, 100, 0, 50),
        BackgroundColor3 = Color3.fromRGB(50, 50, 50),
        [OnEvent "Activated"] = function()
            selectedTab:set(tabName)
        end
    }
end

local function createTabContent(tabName, content)
    return Computed(function()
        return New "Frame" {
            Name = tabName .. "Content",
            Size = UDim2.new(1, 0, 1, -50),
            Position = UDim2.new(0, 0, 0, 50),
            BackgroundColor3 = Color3.fromRGB(40, 40, 40),
            Visible = selectedTab:get() == tabName,
            [Fusion.Children] = content
        }
    end)
end

UI.Main = New "ScreenGui" {
    Name = "Eclipse Hub",
    Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui"),
    
    [Fusion.Children] = {
        New "Frame" {
            Name = "MainFrame",
            Size = UDim2.fromScale(0.5, 0.5),
            Position = UDim2.fromScale(0.25, 0.25),
            BackgroundColor3 = Color3.fromRGB(30, 30, 30),
            [Fusion.Children] = {
                New "Frame" {
                    Name = "TabButtons",
                    Size = UDim2.new(1, 0, 0, 50),
                    BackgroundColor3 = Color3.fromRGB(30, 30, 30),
                    [Fusion.Children] = {
                        createTabButton("Catching"),
                        createTabButton("Physics"),
                        createTabButton("Player"),
                        createTabButton("Configs")
                    }
                },
                createTabContent("Catching", {
                    -- Add Catching tab contents here
local fakeBalls = {}
local pullVectoredBalls = {}

local magnets = Catching:CreateModule("Magnets")
local magnetsType = magnets:CreateSwitch({
	Title = "Type",
	Range = {"Blatant", "Legit", "League", "Custom"}
})
local magnetsCustomRadius = magnets:CreateSlider({
	Title = "Custom Radius",
	Range = {0, 70}
})
local showMagHitbox = magnets:CreateToggle({
	Title = "Show Hitbox"
})

firetouchinterest = (IS_SOLARA) and function(part2, part1, state)
	if AC_BYPASS then
		part1.CFrame = part2.CFrame
	else
		state = state == 1
		local fakeBall = fakeBalls[part1]
		if not fakeBall then return end

		local direction = (part2.Position - fakeBall.Position).Unit
		local distance = (part2.Position - fakeBall.Position).Magnitude

		for i = 1,5,1 do
			local percentage = i/5 + Random.new():NextNumber(0.01, 0.02)
			part1.CFrame = fakeBall.CFrame + (direction * distance * percentage)
		end
	end
end or firetouchinterest


local pullVector = Catching:CreateModule("PullVector")
local pullVectorDistance = pullVector:CreateSlider({
	Title = "Distance",
	Range = {0, 100}
})
local pullVectorType = pullVector:CreateSwitch({
	Title = "Type",
	Range = {"Glide", "Teleport"}
})
local pullVectorPower = pullVector:CreateSlider({
	Title = "Power",
	Range = {1, 5}
})

local velocity = {}
local isCatching = false

local part = Instance.new("Part")
part.Transparency = 0.5
part.Anchored = true
part.CanCollide = false
part.CastShadow = false

local function onCharacterCatching(character)
	local arm = character:WaitForChild('Left Arm')

	arm.ChildAdded:Connect(function(child)
		if not child:IsA("Weld") then return end
		isCatching = true
		task.wait(1.7)
		isCatching = false
	end)
end


workspace.ChildAdded:Connect(function(ball)
	if ball.Name ~= "Football" then return end
	if not ball:IsA("BasePart") then return end
	task.wait()

	local lastPosition = ball.Position
	local lastCheck = os.clock()
	local initalVelocity = ball.AssemblyLinearVelocity

	if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
		local fakeBall = ball:Clone()
		fakeBall.Name = "FFootball"
		fakeBall.Parent = workspace
		fakeBall.Anchored = true
		fakeBall.CanCollide = false
		fakeBall:FindFirstChildWhichIsA('PointLight'):Destroy()
		ball.Transparency = 1
		local spiralDegrees = 0
		fakeBalls[ball] = fakeBall
		task.spawn(function()
			while ball.Parent == workspace do
				local dt = runService.Heartbeat:Wait()
				spiralDegrees += 1500 * dt
				initalVelocity += Vector3.new(0, -28 * dt, 0)
				fakeBall.Position += initalVelocity * dt
				fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)

				if ball:FindFirstChildWhichIsA("Trail") then
					ball:FindFirstChildWhichIsA("Trail").Enabled = false
				end	
			end
			fakeBall:Destroy()
		end)
	end

	while ball.Parent do
		task.wait(0.1)

		local t = (os.clock() - lastCheck)
		velocity[ball] = (ball.Position - lastPosition) / t

		lastCheck = os.clock()
		lastPosition = ball.Position
	end
end)

task.spawn(function()
	while true do
		task.wait(1/60)
		local ball = findClosestBall(); if not ball then part.Parent = nil continue end
		local character = player.Character

		if not character then continue end

		local catchPart = getNearestPartToPartFromParts(ball, {character:FindFirstChild("CatchLeft"), character:FindFirstChild("CatchRight")})

		if not catchPart then continue end
		if not velocity[ball] then continue end
		if not magnets.Value then continue end

		--if magnetsType.Value == "League" then
		--	local predictedPosition = (fakeBalls[ball] or ball).Position + (velocity[ball] * ping)
		--	local distance = (catchPart.Position - predictedPosition).Magnitude
		--	local clientDistance = ((fakeBalls[ball] or ball).Position - catchPart.Position).Magnitude

		--	local y1 = predictedPosition.Y
		--	local y2 = catchPart.Position.Y

		--	part.Position = predictedPosition
		--	part.Parent = showMagHitbox.Value and workspace or nil

		--	part.Color = Color3.fromRGB(255, 255, 255)
		--	part.Size = Vector3.new(4, 1, 2)

		--	if (y1 - y2) > 3.5 then continue end
		--	if (distance) > 4 and clientDistance > 6 then continue end
		--	if not isCatching and IS_SOLARA then continue end

		--	part.Color = Color3.fromRGB(255, 0, 0)

		--	firetouchinterest(atchPart, ball, 0)
		--	firetouchinterest(catchPart, ball, 1)
		
		if magnetsType.Value == "LegitV2" then
			magnetsType.Value = "League"
			magnetsType.Update()
		end
		
		if magnetsType.Value == "League" then
			local predictedPosition = (fakeBalls[ball] or ball).Position + (velocity[ball] * ping)
			local distance = (catchPart.Position - predictedPosition).Magnitude
			
			part.Position = predictedPosition
			part.Size = Vector3.new(magnetsCustomRadius.Value, magnetsCustomRadius.Value, magnetsCustomRadius.Value)
			part.Parent = showMagHitbox.Value and workspace or nil
			
			if distance > magnetsCustomRadius.Value then continue end
			
			firetouchinterest(catchPart, ball, 0)
			firetouchinterest(catchPart, ball, 1)
		else
			local distance = (catchPart.Position - ball.Position).Magnitude
			local radius = ((magnetsType.Value == "Custom" and magnetsCustomRadius.Value) or magnetsType.Value == "Blatant" and 50 or 6)
			part.Position = (fakeBalls[ball] or ball).Position
			part.Size = Vector3.new(radius, radius, radius)
			part.Parent = showMagHitbox.Value and workspace or nil
			part.Color = Color3.fromRGB(173, 173, 173)

			if not isCatching and IS_SOLARA then continue end

			if distance < radius then
				firetouchinterest(catchPart, ball, 0)
				firetouchinterest(catchPart, ball, 1)
			end
		end
	end
end)

task.spawn(function()
	while true do
		task.wait()
		local ball = findClosestBall() if not ball then continue end
		local character = player.Character
		local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

		if not ball:FindFirstChildWhichIsA("Trail") then continue end
		if not character or not humanoidRootPart then continue end
		if not pullVector.Value then continue end
		if pullVectoredBalls[ball] then continue end
		if ball.Anchored then continue end

		local distance = (humanoidRootPart.Position - ball.Position).Magnitude
		if distance > pullVectorDistance.Value then continue end

		local direction = (ball.Position - humanoidRootPart.Position).Unit

		if pullVectorType.Value == "Teleport" then
			pullVectoredBalls[ball] = true
			local distance = 10 + ((pullVectorPower.Value - 1) * 5)
			humanoidRootPart.CFrame += direction * distance
		else
			humanoidRootPart.AssemblyLinearVelocity = direction * pullVectorPower.Value * 25
		end
	end
end)

onCharacterCatching(player.Character)
player.CharacterAdded:Connect(onCharacterCatching)
                    New "TextLabel" {
                        Text = "Catching Module",
                        Size = UDim2.new(1, 0, 0, 50),
                        BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    }
                }),
                createTabContent("Physics", {
                    -- Add Physics tab contents here
local quickTP = Physics:CreateModule("QuickTP")
local quickTPSpeed = quickTP:CreateSlider({
	Title = "Speed",
	Range = {1, 5}
})
local quickTPBind = quickTP:CreateKeybind({
	Title = "Keybind",
	Value = Enum.KeyCode.F
})

local clickTackleAimbot = Physics:CreateModule("ClickTackleAimbot")
local clickTackleAimbotDistance = clickTackleAimbot:CreateSlider({
	Title = "Distance",
	Range = {0, 15}
})

local antiJam = Physics:CreateModule("AntiJam")
local antiBlock = Physics:CreateModule("AntiBlock")

local visualiseBallPath = Physics:CreateModule("VisualiseBallPath")
local noJumpCooldown = Physics:CreateModule("NoJumpCooldown")
local noFreeze = Physics:CreateModule("NoFreeze") 
local optimalJumpPredictions = Physics:CreateModule("OptimalJump")
local noBallTrail = Physics:CreateModule("NoBallTrail")

local bigHead = Physics:CreateModule("BigHead")
local bigHeadSize = bigHead:CreateSlider({
	Title = "Size",
	Range = {1, 5}
})

local optimalJumpType = optimalJumpPredictions:CreateSwitch({
	Title = "Type",
	Range = {"Jump", "Dive"},
	Value = "Jump"
})

local function findPossessor()
	for index, player in pairs(players:GetPlayers()) do
		local character = player.Character; if not character then continue end
		if not character:FindFirstChildWhichIsA("Tool") then continue end
		return player.Character
	end
end

local boundaries = {}

if not IS_PRACTICE then
	for index, part in pairs(workspace.Models.Boundaries:GetChildren()) do
		boundaries[#boundaries + 1] = part
	end
end

local antiOOB; antiOOB = Physics:CreateModule("AntiOOB", nil, function(v)
	v = antiOOB.Value
	for index, boundary in pairs(boundaries) do
		boundary.Parent = not v and workspace.Models.Boundaries or nil
	end
end)

if AC_BYPASS then
	local CFrameSpeed = Physics:CreateModule("CFrameSpeed")
	local CFrameSpeedValue = CFrameSpeed:CreateSlider({
		Title = "Speed",
		Range = {0, 10}
	})

	task.spawn(function()
		while true do task.wait();
			if not CFrameSpeed.Value then continue end
			
			local character = player.Character
			local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
			local humanoid = character and character:FindFirstChild("Humanoid")

			if not humanoidRootPart or not humanoid then continue end

			local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)

			humanoidRootPart.CFrame += moveDirection * (CFrameSpeedValue.Value / 58.5)
		end
	end)
end

if firetouchinterest and not IS_SOLARA then
	local tackleExtender = Physics:CreateModule("TackleExtender")
	local tackleExtenderRadius = tackleExtender:CreateSlider({
		Title = "Radius",
		Range = {0, 10}
	})
	
	task.spawn(function()
		while true do
			task.wait()
			
			local possessor = findPossessor()
			local character = player.Character
			local hrp = character and character:FindFirstChild("HumanoidRootPart")
			
			if not hrp then continue end
			if not possessor then continue end
			
			local distance = (hrp.Position - possessor.HumanoidRootPart.Position).Magnitude
			
			if distance > tackleExtenderRadius.Value then continue end
			
			for index, part in pairs(possessor:GetChildren()) do
				if not part:IsA("BasePart") then continue end
				if not character:FindFirstChild(part.Name) then continue end
				firetouchinterest(character:FindFirstChild(part.Name), part, 0)
				firetouchinterest(character:FindFirstChild(part.Name), part, 1)
			end
		end
	end)
end

if AC_BYPASS then
	local blockExtender = Physics:CreateModule("BlockExtender")
	local blockExtenderRange = blockExtender:CreateSlider({Title = "Range", Range = {1, 20}})
	local blockExtenderRangeTransparency = blockExtender:CreateSlider({Title = "Transparency", Range = {0, 1}, Value = 1})
	
	local flying = false
	local flySpeed = 1
	
	local fly; fly = Physics:CreateModule("Fly", nil, function(v)
		v = fly.Value
		flying = v
		
		if v then
			player.Character.Humanoid.PlatformStand = true
			local bodyVelocity = Instance.new("BodyVelocity", player.Character.HumanoidRootPart)
			local camera = workspace.CurrentCamera
			bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
			bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			local bodyGyro = Instance.new("BodyGyro", player.Character.HumanoidRootPart)
			bodyGyro.P = 15000
			bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
			while flying do
				runService.Stepped:wait()
				local speed = 11 + (flySpeed * 2.5)
				local endPos = camera.CFrame.Position + camera.CFrame.LookVector * 500
				bodyGyro.CFrame = CFrame.new(player.Character.HumanoidRootPart.Position, endPos)
				local velocity = Vector3.new(0, 0, 0)
				if not userInputService:GetFocusedTextBox() then
					if userInputService:IsKeyDown(Enum.KeyCode.W) then
						velocity += camera.CFrame.LookVector * speed
					end
					if userInputService:IsKeyDown(Enum.KeyCode.S) then
						velocity += camera.CFrame.LookVector * -speed
					end
					if userInputService:IsKeyDown(Enum.KeyCode.A) then
						velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(-speed, 0, 0))
					end
					if userInputService:IsKeyDown(Enum.KeyCode.D) then
						velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(speed, 0, 0))
					end
				end
				if player.Character.Humanoid.Health <= 0 then
					flying = false
				end
				bodyVelocity.Velocity = velocity
			end
			player.Character.Humanoid.PlatformStand = false
			bodyGyro:Destroy()
			bodyVelocity:Destroy()
		end
	end)
	
	local flySpeed = fly:CreateSlider({
		Title = "Speed",
		Range = {1, IS_PRACTICE and 20 or 5},
		Callback = function(v)
			flySpeed = v
		end,
	})
	
	task.spawn(function()
		while true do
			task.wait()
			
			local character = player.Character
			local blockPart = character and character:FindFirstChild("BlockPart")
		
			if not blockPart then continue end
			
			blockPart.Size = blockExtender.Value and Vector3.new(blockExtenderRange.Value, blockExtenderRange.Value, blockExtenderRange.Value) or Vector3.new(0.75, 5, 1.5)
			blockPart.Transparency = blockExtender.Value and blockExtenderRangeTransparency.Value or 1
		end
	end)	
end

local function onCharacterPhysics(char)
	local humanoid = char:WaitForChild("Humanoid")
	
	char.DescendantAdded:Connect(function(v)
		task.wait()
		if v.Name:match("FFmover") and antiBlock.Value then
			v:Destroy()
		end
	end)

	task.spawn(function()
		while true do
			task.wait()
			if noJumpCooldown.Value then
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
			end

			local torso = char:FindFirstChild("Torso")
			local head = char:FindFirstChild("Head")

			if not torso or not head then return end

			if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
				torso.CanCollide = not antiJam.Value
				head.CanCollide = not antiJam.Value
			else
				torso.CanCollide = true
				head.CanCollide = true
			end
		end
	end)
end

task.spawn(function()
	local function applyChanges(character)
		local head = character and character:FindFirstChild("Head")
		local mesh = head and head:FindFirstChildWhichIsA("SpecialMesh")

		if not mesh then return end

		mesh.MeshType = bigHead.Value and Enum.MeshType.Sphere or Enum.MeshType.Head
		head.Size = bigHead.Value and Vector3.new(bigHeadSize.Value, 1, bigHeadSize.Value) or Vector3.new(2, 1, 1)
	end
	
	while true do
		task.wait()
		
		for index, player in pairs(players:GetPlayers()) do
			if player == players.LocalPlayer then continue end
			applyChanges(player.Character)
		end
	end
end)

workspace.ChildAdded:Connect(function(ball)
	task.wait()
	if ball.Name ~= "Football" then return end
	if not ball:IsA("BasePart") then return end

	if noBallTrail.Value and ball:FindFirstChildWhichIsA("Trail") then
		ball:FindFirstChildWhichIsA("Trail").Enabled = false
	end

	task.spawn(function()
		if not optimalJumpPredictions.Value then return end
		local initalVelocity = ball.AssemblyLinearVelocity
		local optimalPosition = Vector3.zero

		local currentPosition = ball.Position

		local t = 0

		while true do
			t += 0.05
			initalVelocity += Vector3.new(0, -28 * 0.05, 0)
			currentPosition += initalVelocity * 0.05
			local raycastParams = RaycastParams.new()
			raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Models")}
			raycastParams.FilterType = Enum.RaycastFilterType.Include

			local ray = workspace:Raycast(currentPosition, Vector3.new(0, optimalJumpType.Value == "Jump" and -13 or -15, 0), raycastParams)
			local antiCrashRay = workspace:Raycast(currentPosition, Vector3.new(0, -500, 0), raycastParams)

			if ray and t > 0.75 then
				optimalPosition = ray.Position + Vector3.new(0, 2, 0)
				break
			end

			if not antiCrashRay then
				optimalPosition = currentPosition
				break
			end
		end

		local part = Instance.new("Part")
		part.Anchored = true
		part.Material = Enum.Material.Neon
		part.Size = Vector3.new(1.5, 1.5, 1.5)
		part.Position = optimalPosition
		part.CanCollide = false
		part.Parent = workspace

		repeat task.wait() until ball.Parent ~= workspace

		part:Destroy()
	end)

	task.spawn(function()
		if not visualiseBallPath.Value then return end
		local initalVelocity = ball.AssemblyLinearVelocity
		local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
		a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

		local beam = Instance.new("Beam", workspace.Terrain)
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.Segments = 500
		beam.Width0 = 0.5
		beam.Width1 = 0.5
		beam.Transparency = NumberSequence.new(0)
		beam.Color = ColorSequence.new(Color3.fromHex("#FF8EA5"))

		local g = Vector3.new(0, -28 ,0)
		local x0 = ball.Position
		local v0 = initalVelocity

		local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, 5)

		beam.CurveSize0 = curve0
		beam.CurveSize1 = curve1
		a0.CFrame = a0.Parent.CFrame:inverse() * cf1
		a1.CFrame = a1.Parent.CFrame:inverse() * cf2

		repeat task.wait() until ball.Parent ~= workspace

		beam:Destroy()
	end)
end)

local quickTPCooldown = os.clock()

userInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode ~= quickTPBind.Value then return end

	local character = player.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not quickTP.Value then return end
	if not character or not humanoidRootPart or not humanoid then return end
	if (os.clock() - quickTPCooldown) < 0.1 then return end

	local speed = 2 + (quickTPSpeed.Value / 4)

	humanoidRootPart.CFrame += humanoid.MoveDirection * speed
	quickTPCooldown = os.clock()
end)

mouse.Button1Down:Connect(function()
	if not clickTackleAimbot.Value then return end

	local possessor = findPossessor()
	local character = player.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

	if not character or not humanoidRootPart then return end
	if not possessor then return end

	local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
	if distance > clickTackleAimbotDistance.Value then return end

	humanoidRootPart.CFrame = possessor.HumanoidRootPart.CFrame
end)

onCharacterPhysics(player.Character)
player.CharacterAdded:Connect(onCharacterPhysics)
                    New "TextLabel" {
                        Text = "Physics Module",
                        Size = UDim2.new(1, 0, 0, 50),
                        BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    }
                }),
                createTabContent("Player", {
                    -- Add Player tab contents here
local speed = Player:CreateModule("Speed")
local speedValue = speed:CreateSlider({
	Title = "Speed",
	Range = {20, 23}
})

local jumpPower = Player:CreateModule("JumpPower")
local jumpPowerValue = jumpPower:CreateSlider({
	Title = "Power",
	Range = {50, 70},
})

local angleEnhancer = Player:CreateModule("AngleEnhancer")
local angleEnhancerJP = angleEnhancer:CreateSlider({
	Title = "JP",
	Range = {50, 70}
})
local angleEnhancerIndicator = angleEnhancer:CreateToggle({Title = "Indicator"})

local replicationLag = Player:CreateModule("ReplicationLag")
local replicationLagValue = replicationLag:CreateSlider({
	Title = "Lag",
	Range = {0, 100},
	NonDecimal = false,
	Value = 0
})

--local RTC = Player:CreateModule("RTC")

--local RTCDebug = RTC:CreateToggle({
--	Title = "Debug"
--})

local function onCharacterMovement(character)
	local humanoid = character:WaitForChild("Humanoid")
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

	task.spawn(function()
		while AC_BYPASS and humanoid.Parent do
			task.wait(.1)
			humanoid.JumpPower = jumpPower.Value and jumpPowerValue.Value or 50
		end
	end)

	humanoid.Jumping:Connect(function()
		if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
		if AC_BYPASS then return end
		task.wait(0.05)
		if jumpPower.Value then
			humanoidRootPart.AssemblyLinearVelocity += Vector3.new(0, jumpPowerValue.Value - 50, 0)
		end
	end)
end

onCharacterMovement(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterMovement)

task.spawn(function()
	while true do
		task.wait()
		if not replicationLag.Value then settings():GetService("NetworkSettings").IncomingReplicationLag = 0 continue end
		settings():GetService("NetworkSettings").IncomingReplicationLag = replicationLagValue.Value / 100
	end
end)

task.spawn(function()
	local angleTick = os.clock()
	local oldLookVector = Vector3.new(0, 0, 0)
	
	local shiftLockEnabled = false
	local lastEnabled = false

	local function hookCharacter(character)
		local humanoid = character:WaitForChild("Humanoid")
		local hrp = character:WaitForChild("HumanoidRootPart")

		humanoid.Jumping:Connect(function()
			if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
			if os.clock() - angleTick > 0.2 then return end
			if not angleEnhancer.Value then return end

			if angleEnhancerIndicator.Value then
				local h = Instance.new("Hint")
				h.Text = "Angled"
				h.Parent = workspace

				debris:AddItem(h, 1)
			end
			
			if AC_BYPASS then return end

			task.wait(0.05); hrp.AssemblyLinearVelocity += Vector3.new(0, angleEnhancerJP.Value - 50, 0)
		end)
	end

	hookCharacter(player.Character or player.CharacterAdded:Wait())

	player.CharacterAdded:Connect(hookCharacter)
	
	userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
		if userInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
			shiftLockEnabled = true
		else
			shiftLockEnabled = false
		end
	end)

	while true do
		task.wait()
		local character = player.Character; if not character then continue end
		local hrp = character:FindFirstChild("HumanoidRootPart"); if not hrp then continue end
		local humanoid = character:FindFirstChild("Humanoid"); if not humanoid then continue end

		local lookVector = hrp.CFrame.LookVector
		local difference = (oldLookVector - lookVector).Magnitude

		if not shiftLockEnabled and lastEnabled then
			angleTick = os.clock()
		end
		
		if AC_BYPASS then
			if (os.clock() - angleTick < 0.2) and angleEnhancer.Value then
				humanoid.JumpPower = (jumpPower.Value and jumpPowerValue.Value or 50) + (angleEnhancerJP.Value - 50)
			elseif not angleEnhancer.Value then
				humanoid.JumpPower = (jumpPower.Value and jumpPowerValue.Value or 50)
			end
		end

		oldLookVector = hrp.CFrame.LookVector
		lastEnabled = shiftLockEnabled
	end
end)

runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
	local character = player.Character
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not character or not humanoid then return end
	if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
	if humanoid.WalkSpeed == 0 and not noFreeze.Value then return end
	if not character:FindFirstChild("HumanoidRootPart") then return end

	local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)
	local currentVel = character.HumanoidRootPart.AssemblyLinearVelocity

	if speed.Value or noFreeze.Value then
		local speedValue = speed.Value and (speedValue.Value > 20 and speedValue.Value) or 20
		character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(moveDirection.X * speedValue, currentVel.Y, moveDirection.Z * speedValue)
	end
end)

--task.spawn(function()
--	local sayMessageRequest = replicatedStorage:FindFirstChild("SayMessageRequest", true)

--	local player = players.LocalPlayer
--	local IP = "https://shiny-hardtofind-sphere-devdoroz.replit.app/"

--	local messagesSeen = {}

--	local lastIndex = 0
--	local waitingForJobID = false
	
--	local realPrint = print
--	local print = function(...) if not RTCDebug.Value then return end realPrint(...) end

--	local commands = {
--		["/online"] = function(args)
--			local online = httpService:JSONDecode(request({
--				Url = IP.."/get-online",
--				Method = "POST"
--			}).Body)

--			local str = "There are "..#online.." players online right now: "

--			for index, player in pairs(online) do
--				str ..= player..", "
--			end

--			str = string.sub(str, 1, #str - 2)
--			createMessage(str)
--		end,
--		["/rtc"] = function(...)
--			local args = {...}
--			send(table.concat(args, " "))
--		end,
--		["/help"] = function()
--			createMessage("/online to get players online")
--			createMessage("/rtc to send a message")
--			createMessage("/join {player-name} to join a player")
--		end,
--		["/join"] = function(...)
--			local args = {...}
--			print(unpack(args))
--			waitingForJobID = true
--			print("Attempting to get job id of ", args[1])
--			send(nil, "get-job-id", {
--				User = args[1],
--				type = "get-job-id"
--			})
--		end,
--	}

--	function send(message, type, data)
--		return request({
--			Url = IP.."/message",
--			Method = "POST",
--			Body = httpService:JSONEncode(data or {
--				User = player.Name,
--				Message = message,
--				type = type or "message"
--			}),
--			Headers = {
--				["Content-Type"] = "application/json"
--			}
--		})
--	end
	
--	local receivingThread = nil

--	function receive()
--		local response = nil
		
--		task.spawn(function()
--			response = request({
--				Url = IP.."/message",
--				Method = "GET",
--			}).Body
--		end)
		
--		repeat task.wait() until response or not RTC.Value
		
--		writefile("bleachhackresponse.json", response)
		
--		return response
--	end

--	function heartbeat()
--		request({
--			Url = IP.."/heartbeat",
--			Method = "POST",
--			Body = httpService:JSONEncode({
--				User = player.Name,
--			}),
--			Headers = {
--				["Content-Type"] = "application/json"
--			}
--		})
--	end

--	function createMessage(text)
--		starterGui:SetCore("ChatMakeSystemMessage", {
--			Text = text,
--			Font = Enum.Font.SourceSans;
--			Color = Color3.fromRGB(0, 166, 255),
--			FontSize = Enum.FontSize.Size24;
--		})
--	end

--	player.Chatted:Connect(function(msg)
--		local command = string.split(msg, " ")[1]
--		local isCommand = commands[command]
--		if not isCommand then return end

--		sayMessageRequest.Parent = nil

--		commands[command](unpack(string.split(string.sub(msg, #command + 2, #msg), " ")))

--		task.wait()

--		sayMessageRequest.Parent = replicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
--	end)

--	task.spawn(function()
--		while true do
--			repeat task.wait() until RTC.Value
--			print("[RTC] Sending heartbeat...")
--			heartbeat()
--			print('[RTC] Successfully heartbeat!')
--			task.wait(5)
--		end
--	end)

--	task.spawn(function()
--		repeat task.wait() until RTC.Value
--		createMessage("Successfully connected to Bleachhack RTC.")
--		createMessage("/help to see commands!")
--		createMessage("THIS IS STILL EXPERIMENTAL, EXPECT BUGS")
--	end)
	
--	while true do
--		task.wait()
--		if not RTC.Value then continue end
--		local logs = httpService:JSONDecode(receive() or "[]")
--		if not RTC.Value then continue end

--		if lastIndex == 0 then
--			lastIndex = #logs
--			continue
--		end

--		print(logs)

--		print("Received a new message.", lastIndex)

--		for i = lastIndex + 1,#logs,1 do
--			local data = logs[i]
--			print("Reading message", data.type, data.user, data.message, i)
--			if data.type == "message" then
--				createMessage("[RTC] "..data.user..": "..data.message)
--			elseif data.type == "join" then
--				createMessage("[RTC] "..data.user.." joined")
--			elseif data.type == "leave" then
--				createMessage("[RTC] "..data.user.." has left")
--			elseif data.type == "get-job-id" then
--				task.delay(0.5, function()
--					if data.user:match(player.Name) then
--						print("Passed over job-id")
--						send(game.JobId, "job-id")
--					else
--						print(data.user, " invalid compare check for get-job-id")
--					end
--				end)
--			elseif data.type == "job-id" then
--				if waitingForJobID then
--					local message = Instance.new("Message")
--					message.Text = "Teleporting.."
--					message.Parent = workspace
--					print('[RTC] FOUND JOB-ID, teleporting')
--					RTC.Value = false
--					getgenv()['script_key'] = getgenv()['script_key'] or "KbEpNXxrYdzAGikrnSYfYVRXdRnNKXrb";
--					local queued = "script_key='"..getgenv()['script_key'].."'; getgenv().script_key="..getgenv()['script_key']..'; loadstring(game:HttpGet("https://raw.githubusercontent.com/devdoroz/bleachhack/main/loader.lua"))()'
--					queue_on_teleport(queued)
--					print("Queued code, "..queued)
--					task.delay(3, function()
--						game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, data.message, player)
--					end)
--				else
--					print('[RTC] Skipped job-id, not waiting for')
--				end
--			end
--		end

--		print("Finished ", lastIndex)

--		lastIndex = #logs
--	end
--end)
                    New "TextLabel" {
                        Text = "Player Module",
                        Size = UDim2.new(1, 0, 0, 50),
                        BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    }
                }),
                createTabContent("Configs", {
                    -- Add Configs tab contents here
local Save = Configs:CreateModule("Save", true, function()
	configSavingUI.Enabled = true
	
	local configName = nil
	
	local connection; connection = configSavingUI.Frame.ConfirmButton.MouseButton1Click:Connect(function()
		configName = configSavingUI.Frame.ConfigName.Text
		connection:Disconnect()
	end)
	
	repeat task.wait() until configName
	
	configSavingUI.Enabled = false
	
	local exported = UI:Export()
	
	writefile("Eclipse Hub/"..configName..".json", exported)
end)

local Load = Configs:CreateModule("Load", true, function()
	configSavingUI.Enabled = true

	local configName = nil

	local connection; connection = configSavingUI.Frame.ConfirmButton.MouseButton1Click:Connect(function()
		configName = configSavingUI.Frame.ConfigName.Text
		connection:Disconnect()
	end)

	repeat task.wait() until configName

	configSavingUI.Enabled = false
	
	if not isfile("Eclipse Hub/"..configName..".json") then return end
	
	local contents = readfile("Eclipse Hub/"..configName..".json")
	
	UI:Import(contents)
end)
                    New "TextLabel" {
                        Text = "Configs Module",
                        Size = UDim2.new(1, 0, 0, 50),
                        BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    }
                })
            }
        }
    }
}

return UI

local Fusion = require(game.ReplicatedStorage.Fusion)
local UI = require(game.ReplicatedStorage.FusionUI)

local players = game:GetService("Players")
local statsService = game:GetService("Stats")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local starterGui = game:GetService("StarterGui")
local debris = game:GetService("Debris")

local player = players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera
local values = replicatedStorage:FindFirstChild("Values")

local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = string.match(getexecutorname(), "Solara")
local AC_BYPASS = IS_PRACTICE

local ping = 0
local fps = 0

function getPing()
    return statsService.PerformanceStats.Ping:GetValue()
end

function getServerPing()
    return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
end

function findClosestBall()
    local lowestDistance = math.huge
    local nearestBall = nil

    local character = player.Character

    for index, ball in pairs(workspace:GetChildren()) do
        if ball.Name ~= "Football" then continue end
        if not ball:IsA("BasePart") then continue end
        if not character:FindFirstChild("HumanoidRootPart") then continue end
        local distance = (ball.Position - character.HumanoidRootPart.Position).Magnitude

        if distance < lowestDistance then
            nearestBall = ball
            lowestDistance = distance
        end
    end

    return nearestBall
end

function beamProjectile(g, v0, x0, t1)
    local c = 0.5*0.5*0.5;
    local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
    local p2 = p3 - (g*t1*t1 + v0*t1)/3;
    local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

    local curve0 = (p1 - x0).magnitude;
    local curve1 = (p2 - p3).magnitude;

    local b = (x0 - p3).unit;
    local r1 = (p1 - x0).unit;
    local u1 = r1:Cross(b).unit;
    local r2 = (p2 - p3).unit;
    local u2 = r2:Cross(b).unit;
    b = u1:Cross(r1).unit;

    local cf1 = CFrame.new(
        x0.x, x0.y, x0.z,
        r1.x, u1.x, b.x,
        r1.y, u1.y, b.y,
        r1.z, u1.z, b.z
    )

    local cf2 = CFrame.new(
        p3.x, p3.y, p3.z,
        r2.x, u2.x, b.x,
        r2.y, u2.y, b.y,
        r2.z, u2.z, b.z
    )

    return curve0, -curve1, cf1, cf2;
end

function getNearestPartToPartFromParts(part, parts)
    local lowestDistance = math.huge
    local nearestPart = nil

    for index, p in pairs(parts) do
        local distance = (part.Position - p.Position).Magnitude

        if distance < lowestDistance then
            nearestPart = p
            lowestDistance = distance
        end
    end

    return nearestPart
end

task.spawn(function()
    while true do
        task.wait(0.1)
        ping = ( getPing() + getServerPing() ) / 1000
    end
end)

task.spawn(function()
    runService.RenderStepped:Connect(function()
        fps += 1
        task.delay(1, function()
            fps -= 1
        end)
    end)
end)

--// catching

local fakeBalls = {}
local pullVectoredBalls = {}

local magnets = Catching:CreateModule("Magnets")
local magnetsType = magnets:CreateSwitch({
    Title = "Type",
    Range = {"Blatant", "Legit", "League", "Custom"}
})
local magnetsCustomRadius = magnets:CreateSlider({
    Title = "Custom Radius",
    Range = {0, 70}
})
local showMagHitbox = magnets:CreateToggle({
    Title = "Show Hitbox"
})

firetouchinterest = (IS_SOLARA) and function(part2, part1, state)
    if AC_BYPASS then
        part1.CFrame = part2.CFrame
    else
        state = state == 1
        local fakeBall = fakeBalls[part1]
        if not fakeBall then return end

        local direction = (part2.Position - fakeBall.Position).Unit
        local distance = (part2.Position - fakeBall.Position).Magnitude

        for i = 1,5,1 do
            local percentage = i/5 + Random.new():NextNumber(0.01, 0.02)
            part1.CFrame = fakeBall.CFrame + (direction * distance * percentage)
        end
    end
end or firetouchinterest

local pullVector = Catching:CreateModule("PullVector")
local pullVectorDistance = pullVector:CreateSlider({
    Title = "Distance",
    Range = {0, 100}
})
local pullVectorType = pullVector:CreateSwitch({
    Title = "Type",
    Range = {"Glide", "Teleport"}
})
local pullVectorPower = pullVector:CreateSlider({
    Title = "Power",
    Range = {1, 5}
})

local velocity = {}
local isCatching = false

local part = Instance.new("Part")
part.Transparency = 0.5
part.Anchored = true
part.CanCollide = false
part.CastShadow = false

local function onCharacterCatching(character)
    local arm = character:WaitForChild('Left Arm')

    arm.ChildAdded:Connect(function(child)
        if not child:IsA("Weld") then return end
        isCatching = true
        task.wait(1.7)
        isCatching = false
    end)
end

workspace.ChildAdded:Connect(function(ball)
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end
    task.wait()

    local lastPosition = ball.Position
    local lastCheck = os.clock()
    local initalVelocity = ball.AssemblyLinearVelocity

    if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
        local fakeBall = ball:Clone()
        fakeBall.Name = "FFootball"
        fakeBall.Parent = workspace
        fakeBall.Anchored = true
        fakeBall.CanCollide = false
        fakeBall:FindFirstChildWhichIsA('PointLight'):Destroy()
        ball.Transparency = 1
        local spiralDegrees = 0
        fakeBalls[ball] = fakeBall
        task.spawn(function()
            while ball.Parent == workspace do
                local dt = runService.Heartbeat:Wait()
                spiralDegrees += 1500 * dt
                initalVelocity += Vector3.new(0, -28 * dt, 0)
                fakeBall.Position += initalVelocity * dt
                fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)

                if ball:FindFirstChildWhichIsA("Trail") then
                    ball:FindFirstChildWhichIsA("Trail").Enabled = false
                end    
            end
            fakeBall:Destroy()
        end)
    end

    while ball.Parent do
        task.wait(0.1)

        local t = (os.clock() - lastCheck)
        velocity[ball] = (ball.Position - lastPosition) / t

        lastCheck = os.clock()
        lastPosition = ball.Position
    end
end)

task.spawn(function()
    while true do
        task.wait(1/60)
        local ball = findClosestBall(); if not ball then part.Parent = nil continue end
        local character = player.Character

        if not character then continue end

        local catchPart = getNearestPartToPartFromParts(ball, {character:FindFirstChild("CatchLeft"), character:FindFirstChild("CatchRight")})

        if not catchPart then continue end
        if not velocity[ball] then continue end
        if not magnets.Value then continue end

        if magnetsType.Value == "LegitV2" then
            magnetsType.Value = "League"
            magnetsType.Update()
        end
        
        if magnetsType.Value == "League" then
            local predictedPosition = (fakeBalls[ball] or ball).Position + (velocity[ball] * ping)
            local distance = (catchPart.Position - predictedPosition).Magnitude
            
            part.Position = predictedPosition
            part.Size = Vector3.new(magnetsCustomRadius.Value, magnetsCustomRadius.Value, magnetsCustomRadius.Value)
            part.Parent = showMagHitbox.Value and workspace or nil
            
            if distance > magnetsCustomRadius.Value then continue end
            
            firetouchinterest(catchPart, ball, 0)
            firetouchinterest(catchPart, ball, 1)
        else
            local distance = (catchPart.Position - ball.Position).Magnitude
            local radius = ((magnetsType.Value == "Custom" and magnetsCustomRadius.Value) or magnetsType.Value == "Blatant" and 50 or 6)
            part.Position = (fakeBalls[ball] or ball).Position
            part.Size = Vector3.new(radius, radius, radius)
            part.Parent = showMagHitbox.Value and workspace or nil
            part.Color = Color3.fromRGB(173, 173, 173)

            if not isCatching and IS_SOLARA then continue end

            if distance < radius then
                firetouchinterest(catchPart, ball, 0)
                firetouchinterest(catchPart, ball, 1)
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()
        local ball = findClosestBall() if not ball then continue end
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not ball:FindFirstChildWhichIsA("Trail") then continue end
        if not character or not humanoidRootPart then continue end
        if not pullVector.Value then continue end
        if pullVectoredBalls[ball] then continue end
        if ball.Anchored then continue end

        local distance = (humanoidRootPart.Position - ball.Position).Magnitude
        if distance > pullVectorDistance.Value then continue end

        local direction = (ball.Position - humanoidRootPart.Position).Unit

        if pullVectorType.Value == "Teleport" then
            pullVectoredBalls[ball] = true
            local distance = 10 + ((pullVectorPower.Value - 1) * 5)
            humanoidRootPart.CFrame += direction * distance
        else
            humanoidRootPart.AssemblyLinearVelocity = direction * pullVectorPower.Value * 25
        end
    end
end)

onCharacterCatching(player.Character)
player.CharacterAdded:Connect(onCharacterCatching)

--// physics

local quickTP = Physics:CreateModule("QuickTP")
local quickTPSpeed = quickTP:CreateSlider({
    Title = "Speed",
    Range = {1, 5}
})
local quickTPBind = quickTP:CreateKeybind({
    Title = "Keybind",
    Value = Enum.KeyCode.F
})

local clickTackleAimbot = Physics:CreateModule("ClickTackleAimbot")
local clickTackleAimbotDistance = clickTackleAimbot:CreateSlider({
    Title = "Distance",
    Range = {0, 15}
})

local antiJam = Physics:CreateModule("AntiJam")
local antiBlock = Physics:CreateModule("AntiBlock")

local visualiseBallPath = Physics:CreateModule("VisualiseBallPath")
local noJumpCooldown = Physics:CreateModule("NoJumpCooldown")
local noFreeze = Physics:CreateModule("NoFreeze") 
local optimalJumpPredictions = Physics:CreateModule("OptimalJump")
local noBallTrail = Physics:CreateModule("NoBallTrail")

local bigHead = Physics:CreateModule("BigHead")
local bigHeadSize = bigHead:CreateSlider({
    Title = "Size",
    Range = {1, 5}
})

local optimalJumpType = optimalJumpPredictions:CreateSwitch({
    Title = "Type",
    Range = {"Jump", "Dive"},
    Value = "Jump"
})

local function findPossessor()
    for index, player in pairs(players:GetPlayers()) do
        local character = player.Character; if not character then continue end
        if not character:FindFirstChildWhichIsA("Tool") then continue end
        return player.Character
    end
end

local boundaries = {}

if not IS_PRACTICE then
    for index, part in pairs(workspace.Models.Boundaries:GetChildren()) do
        boundaries[#boundaries + 1] = part
    end
end

local antiOOB; antiOOB = Physics:CreateModule("AntiOOB", nil, function(v)
    v = antiOOB.Value
    for index, boundary in pairs(boundaries) do
        boundary.Parent = not v and workspace.Models.Boundaries or nil
    end
end)

if AC_BYPASS then
    local CFrameSpeed = Physics:CreateModule("CFrameSpeed")
    local CFrameSpeedValue = CFrameSpeed:CreateSlider({
        Title = "Speed",
        Range = {0, 10}
    })

    task.spawn(function()
        while true do task.wait();
            if not CFrameSpeed.Value then continue end
            
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            local humanoid = character and character:FindFirstChild("Humanoid")

            if not humanoidRootPart or not humanoid then continue end

            local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)

            humanoidRootPart.CFrame += moveDirection * (CFrameSpeedValue.Value / 58.5)
        end
    end)
end

if firetouchinterest and not IS_SOLARA then
    local tackleExtender = Physics:CreateModule("TackleExtender")
    local tackleExtenderRadius = tackleExtender:CreateSlider({
        Title = "Radius",
        Range = {0, 10}
    })
    
    task.spawn(function()
        while true do
            task.wait()
            
            local possessor = findPossessor()
			local character = player.Character
			local hrp = character and character:FindFirstChild("HumanoidRootPart")
			
			if not hrp then continue end
			if not possessor then continue end
			
			local distance = (hrp.Position - possessor.HumanoidRootPart.Position).Magnitude
			
			if distance > tackleExtenderRadius.Value then continue end
			
			for index, part in pairs(possessor:GetChildren()) do
				if not part:IsA("BasePart") then continue end
				if not character:FindFirstChild(part.Name) then continue end
				firetouchinterest(character:FindFirstChild(part.Name), part, 0)
				firetouchinterest(character:FindFirstChild(part.Name), part, 1)
			end
		end
	end)
end

if AC_BYPASS then
	local blockExtender = Physics:CreateModule("BlockExtender")
	local blockExtenderRange = blockExtender:CreateSlider({Title = "Range", Range = {1, 20}})
	local blockExtenderRangeTransparency = blockExtender:CreateSlider({Title = "Transparency", Range = {0, 1}, Value = 1})
	
	local flying = false
	local flySpeed = 1
	
	local fly; fly = Physics:CreateModule("Fly", nil, function(v)
		v = fly.Value
		flying = v
		
		if v then
			player.Character.Humanoid.PlatformStand = true
			local bodyVelocity = Instance.new("BodyVelocity", player.Character.HumanoidRootPart)
			local camera = workspace.CurrentCamera
			bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
			bodyVelocity.Velocity = Vector3.new(0, 0, 0)
			local bodyGyro = Instance.new("BodyGyro", player.Character.HumanoidRootPart)
			bodyGyro.P = 15000
			bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
			while flying do
				runService.Stepped:wait()
				local speed = 11 + (flySpeed * 2.5)
				local endPos = camera.CFrame.Position + camera.CFrame.LookVector * 500
				bodyGyro.CFrame = CFrame.new(player.Character.HumanoidRootPart.Position, endPos)
				local velocity = Vector3.new(0, 0, 0)
				if not userInputService:GetFocusedTextBox() then
					if userInputService:IsKeyDown(Enum.KeyCode.W) then
						velocity += camera.CFrame.LookVector * speed
					end
					if userInputService:IsKeyDown(Enum.KeyCode.S) then
						velocity += camera.CFrame.LookVector * -speed
					end
					if userInputService:IsKeyDown(Enum.KeyCode.A) then
						velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(-speed, 0, 0))
					end
					if userInputService:IsKeyDown(Enum.KeyCode.D) then
						velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(speed, 0, 0))
					end
				end
				if player.Character.Humanoid.Health <= 0 then
					flying = false
				end
				bodyVelocity.Velocity = velocity
			end
			player.Character.Humanoid.PlatformStand = false
			bodyGyro:Destroy()
			bodyVelocity:Destroy()
		end
	end)
	
	local flySpeed = fly:CreateSlider({
		Title = "Speed",
		Range = {1, IS_PRACTICE and 20 or 5},
		Callback = function(v)
			flySpeed = v
		end,
	})
	
	task.spawn(function()
		while true do
			task.wait()
			
			local character = player.Character
			local blockPart = character and character:FindFirstChild("BlockPart")
		
			if not blockPart then continue end
			
			blockPart.Size = blockExtender.Value and Vector3.new(blockExtenderRange.Value, blockExtenderRange.Value, blockExtenderRange.Value) or Vector3.new(0.75, 5, 1.5)
			blockPart.Transparency = blockExtender.Value and blockExtenderRangeTransparency.Value or 1
		end
	end)	
end

local function onCharacterPhysics(char)
	local humanoid = char:WaitForChild("Humanoid")
	
	char.DescendantAdded:Connect(function(v)
		task.wait()
		if v.Name:match("FFmover") and antiBlock.Value then
			v:Destroy()
		end
	end)

	task.spawn(function()
		while true do
			task.wait()
			if noJumpCooldown.Value then
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
			end

			local torso = char:FindFirstChild("Torso")
			local head = char:FindFirstChild("Head")

			if not torso or not head then return end

			if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
				torso.CanCollide = not antiJam.Value
				head.CanCollide = not antiJam.Value
			else
				torso.CanCollide = true
				head.CanCollide = true
			end
		end
	end)
end

task.spawn(function()
	local function applyChanges(character)
		local head = character and character:FindFirstChild("Head")
		local mesh = head and head:FindFirstChildWhichIsA("SpecialMesh")

		if not mesh then return end

		mesh.MeshType = bigHead.Value and Enum.MeshType.Sphere or Enum.MeshType.Head
		head.Size = bigHead.Value and Vector3.new(bigHeadSize.Value, 1, bigHeadSize.Value) or Vector3.new(2, 1, 1)
	end
	
	while true do
		task.wait()
		
		for index, player in pairs(players:GetPlayers()) do
			if player == players.LocalPlayer then continue end
			applyChanges(player.Character)
		end
	end
end)

workspace.ChildAdded:Connect(function(ball)
	task.wait()
	if ball.Name ~= "Football" then return end
	if not ball:IsA("BasePart") then return end

	if noBallTrail.Value and ball:FindFirstChildWhichIsA("Trail") then
		ball:FindFirstChildWhichIsA("Trail").Enabled = false
	end

	task.spawn(function()
		if not optimalJumpPredictions.Value then return end
		local initalVelocity = ball.AssemblyLinearVelocity
		local optimalPosition = Vector3.zero

		local currentPosition = ball.Position

		local t = 0

		while true do
			t += 0.05
			initalVelocity += Vector3.new(0, -28 * 0.05, 0)
			currentPosition += initalVelocity * 0.05
			local raycastParams = RaycastParams.new()
			raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Models")}
			raycastParams.FilterType = Enum.RaycastFilterType.Include

			local ray = workspace:Raycast(currentPosition, Vector3.new(0, optimalJumpType.Value == "Jump" and -13 or -15, 0), raycastParams)
			local antiCrashRay = workspace:Raycast(currentPosition, Vector3.new(0, -500, 0), raycastParams)

			if ray and t > 0.75 then
				optimalPosition = ray.Position + Vector3.new(0, 2, 0)
				break
			end

			if not antiCrashRay then
				optimalPosition = currentPosition
				break
			end
		end

		local part = Instance.new("Part")
		part.Anchored = true
		part.Material = Enum.Material.Neon
		part.Size = Vector3.new(1.5, 1.5, 1.5)
		part.Position = optimalPosition
		part.CanCollide = false
		part.Parent = workspace

		repeat task.wait() until ball.Parent ~= workspace

		part:Destroy()
	end)

	task.spawn(function()
		if not visualiseBallPath.Value then return end
		local initalVelocity = ball.AssemblyLinearVelocity
		local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
		a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

		local beam = Instance.new("Beam", workspace.Terrain)
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.Segments = 500
		beam.Width0 = 0.5
		beam.Width1 = 0.5
		beam.Transparency = NumberSequence.new(0)
		beam.Color = ColorSequence.new(Color3.fromHex("#FF8EA5"))

		local g = Vector3.new(0, -28 ,0)
		local x0 = ball.Position
		local v0 = initalVelocity

		local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, 5)

		beam.CurveSize0 = curve0
		beam.CurveSize1 = curve1
		a0.CFrame = a0.Parent.CFrame:inverse() * cf1
		a1.CFrame = a1.Parent.CFrame:inverse() * cf2

		repeat task.wait() until ball.Parent ~= workspace

		beam:Destroy()
	end)
end)

local quickTPCooldown = os.clock()

userInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode ~= quickTPBind.Value then return end

	local character = player.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not quickTP.Value then return end
	if not character or not humanoidRootPart or not humanoid then return end
	if (os.clock() - quickTPCooldown) < 0.1 then return end

	local speed = 2 + (quickTPSpeed.Value / 4)

	humanoidRootPart.CFrame += humanoid.MoveDirection * speed
	quickTPCooldown = os.clock()
end)

mouse.Button1Down:Connect(function()
	if not clickTackleAimbot.Value then return end

	local possessor = findPossessor()
	local character = player.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

	if not character or not humanoidRootPart then return end
	if not possessor then return end

	local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
	if distance > clickTackleAimbotDistance.Value then return end

	humanoidRootPart.CFrame = possessor.HumanoidRootPart.CFrame
end)

onCharacterPhysics(player.Character)
player.CharacterAdded:Connect(onCharacterPhysics)

--// player

local speed = Player:CreateModule("Speed")
local speedValue = speed:CreateSlider({
	Title = "Speed",
	Range = {20, 23}
})

local jumpPower = Player:CreateModule("JumpPower")
local jumpPowerValue = jumpPower:CreateSlider({
	Title = "Power",
	Range = {50, 70},
})

local angleEnhancer = Player:CreateModule("AngleEnhancer")
local angleEnhancerJP = angleEnhancer:CreateSlider({
	Title = "JP",
	Range = {50, 70}
})
local angleEnhancerIndicator = angleEnhancer:CreateToggle({Title = "Indicator"})

local replicationLag = Player:CreateModule("ReplicationLag")
local replicationLagValue = replicationLag:CreateSlider({
	Title = "Lag",
	Range = {0, 100},
	NonDecimal = false,
	Value = 0
})

--local RTC = Player:CreateModule("RTC")

--local RTCDebug = RTC:CreateToggle({
--	Title = "Debug"
--})

local function onCharacterMovement(character)
	local humanoid = character:WaitForChild("Humanoid")
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

	task.spawn(function()
		while AC_BYPASS and humanoid.Parent do
			task.wait(.1)
			humanoid.JumpPower = jumpPower.Value and jumpPowerValue.Value or 50
		end
	end)

	humanoid.Jumping:Connect(function()
		if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
		if AC_BYPASS then return end
		task.wait(0.05)
		if jumpPower.Value then
			humanoidRootPart.AssemblyLinearVelocity += Vector3.new(0, jumpPowerValue.Value - 50, 0)
		end
	end)
end

onCharacterMovement(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterMovement)

task.spawn(function()
	while true do
		task.wait()
		if not replicationLag.Value then settings():GetService("NetworkSettings").IncomingReplicationLag = 0 continue end
		settings():GetService("NetworkSettings").IncomingReplicationLag = replicationLagValue.Value / 100
	end
end)

task.spawn(function()
	local angleTick = os.clock()
	local oldLookVector = Vector3.new(0, 0, 0)
	
	local shiftLockEnabled = false
	local lastEnabled = false

	local function hookCharacter(character)
		local humanoid = character:WaitForChild("Humanoid")
		local hrp = character:WaitForChild("HumanoidRootPart")

		humanoid.Jumping:Connect(function()
			if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
			if os.clock() - angleTick > 0.2 then return end
			if not angleEnhancer.Value then return end

			if angleEnhancerIndicator.Value then
				local h = Instance.new("Hint")
				h.Text = "Angled"
				h.Parent = workspace

				debris:AddItem(h, 1)
			end
			
			if AC_BYPASS then return end

			task.wait(0.05); hrp.AssemblyLinearVelocity += Vector3.new(0, angleEnhancerJP.Value - 50, 0)
		end)
	end

	hookCharacter(player.Character or player.CharacterAdded:Wait())

	player.CharacterAdded:Connect(hookCharacter)
	
	userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
		if userInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
			shiftLockEnabled = true
		else
			shiftLockEnabled = false
		end
	end)

	while true do
		task.wait()
		local character = player.Character; if not character then continue end
		local hrp = character:FindFirstChild("HumanoidRootPart"); if not hrp then continue end
		local humanoid = character:FindFirstChild("Humanoid"); if not humanoid then continue end

		local lookVector = hrp.CFrame.LookVector
		local difference = (oldLookVector - lookVector).Magnitude

		if not shiftLockEnabled and lastEnabled then
			angleTick = os.clock()
		end
		
		if AC_BYPASS then
			if (os.clock() - angleTick < 0.2) and angleEnhancer.Value then
				humanoid.JumpPower = (jumpPower.Value and jumpPowerValue.Value or 50) + (angleEnhancerJP.Value - 50)
			elseif not angleEnhancer.Value then
				humanoid.JumpPower = (jumpPower.Value and jumpPowerValue.Value or 50)
			end
		end

		oldLookVector = hrp.CFrame.LookVector
		lastEnabled = shiftLockEnabled
	end
end)

runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
	local character = player.Character
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not character or not humanoid then return end
	if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
	if humanoid.WalkSpeed == 0 and not noFreeze.Value then return end
	if not character:FindFirstChild("HumanoidRootPart") then return end

	local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)
	local currentVel = character.HumanoidRootPart.AssemblyLinearVelocity

	if speed.Value or noFreeze.Value then
		local speedValue = speed.Value and (speedValue.Value > 20 and speedValue.Value) or 20
		character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(moveDirection.X * speedValue, currentVel.Y, moveDirection.Z * speedValue)
	end
end)

--task.spawn(function()
--	local sayMessageRequest = replicatedStorage:FindFirstChild("SayMessageRequest", true)

--	local player = players.LocalPlayer
--	local IP = "https://shiny-hardtofind-sphere-devdoroz.replit.app/"

--	local messagesSeen = {}

--	local lastIndex = 0
--	local waitingForJobID = false
	
--	local realPrint = print
--	local print = function(...) if not RTCDebug.Value then return end realPrint(...) end

--	local commands = {
--		["/online"] = function(args)
--			local online = httpService:JSONDecode(request({
--				Url = IP.."/get-online",
--				Method = "POST"
--			}).Body)

--			local str = "There are "..#online.." players online right now: "

--			for index, player in pairs(online) do
--				str ..= player..", "
--			end

--			str = string.sub(str, 1, #str - 2)
--			createMessage(str)
--		end,
--		["/rtc"] = function(...)
--			local args = {...}
--			send(table.concat(args, " "))
--		end,
--		["/help"] = function()
--			createMessage("/online to get players online")
--			createMessage("/rtc to send a message")
--			createMessage("/join {player-name} to join a player")
--		end,
--		["/join"] = function(...)
--			local args = {...}
--			print(unpack(args))
--			waitingForJobID = true
--			print("Attempting to get job id of ", args[1])
--			send(nil, "get-job-id", {
--				User = args[1],
--				type = "get-job-id"
--			})
--		end,
--	}

--	function send(message, type, data)
--		return request({
--			Url = IP.."/message",
--			Method = "POST",
--			Body = httpService:JSONEncode(data or {
--				User = player.Name,
--				Message = message,
--				type = type or "message"
--			}),
--			Headers = {
--				["Content-Type"] = "application/json"
--			}
--		})
--	end
	
--	local receivingThread = nil

--	function receive()
--		local response = nil
		
--		task.spawn(function()
--			response = request({
--				Url = IP.."/message",
--				Method = "GET",
--			}).Body
--		end)
		
--		repeat task.wait() until response or not RTC.Value
		
--		writefile("bleachhackresponse.json", response)
		
--		return response
--	end

--	function heartbeat()
--		request({
--			Url = IP.."/heartbeat",
--			Method = "POST",
--			Body = httpService:JSONEncode({
--				User = player.Name,
--			}),
--			Headers = {
--				["Content-Type"] = "application/json"
--			}
--		})
--	end

--	function createMessage(text)
--		starterGui:SetCore("ChatMakeSystemMessage", {
--			Text = text,
--			Font = Enum.Font.SourceSans;
--			Color = Color3.fromRGB(0, 166, 255),
--			FontSize = Enum.FontSize.Size24;
--		})
--	end

--	player.Chatted:Connect(function(msg)
--		local command = string.split(msg, " ")[1]
--		local isCommand = commands[command]
--		if not isCommand then return end

--		sayMessageRequest.Parent = nil

--		commands[command](unpack(string.split(string.sub(msg, #command + 2, #msg), " ")))

--		task.wait()

--		sayMessageRequest.Parent = replicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
--	end)

--	task.spawn(function()
--		while true do
--			repeat task.wait() until RTC.Value
--			print("[RTC] Sending heartbeat...")
--			heartbeat()
--			print('[RTC] Successfully heartbeat!')
--			task.wait(5)
--		end
--	end)

--	task.spawn(function()
--		repeat task.wait() until RTC.Value
--		createMessage("Successfully connected to Bleachhack RTC.")
--		createMessage("/help to see commands!")
--		createMessage("THIS IS STILL EXPERIMENTAL, EXPECT BUGS")
--	end)
	
--	while true do
--		task.wait()
--		if not RTC.Value then continue end
--		local logs = httpService:JSONDecode(receive() or "[]")
--		if not RTC.Value then continue end

--		if lastIndex == 0 then
--			lastIndex = #logs
--			continue
--		end

--		print(logs)

--		print("Received a new message.", lastIndex)

--		for i = lastIndex + 1,#logs,1 do
--			local data = logs[i]
--			print("Reading message", data.type, data.user, data.message, i)
--			if data.type == "message" then
--				createMessage("[RTC] "..data.user..": "..data.message)
--			elseif data.type == "join" then
--				createMessage("[RTC] "..data.user.." joined")
--			elseif data.type == "leave" then
--				createMessage("[RTC] "..data.user.." has left")
--			elseif data.type == "get-job-id" then
--				task.delay(0.5, function()
--					if data.user:match(player.Name) then
--						print("Passed over job-id")
--						send(game.JobId, "job-id")
--					else
--						print(data.user, " invalid compare check for get-job-id")
--					end
--				end)
--			elseif data.type == "job-id" then
--				if waitingForJobID then
--					local message = Instance.new("Message")
--					message.Text = "Teleporting.."
--					message.Parent = workspace
--					print('[RTC] FOUND JOB-ID, teleporting')
--					RTC.Value = false
--					getgenv()['script_key'] = getgenv()['script_key'] or "KbEpNXxrYdzAGikrnSYfYVRXdRnNKXrb";
--					local queued = "script_key='"..getgenv()['script_key'].."'; getgenv().script_key="..getgenv()['script_key']..'; loadstring(game:HttpGet("https://raw.githubusercontent.com/devdoroz/bleachhack/main/loader.lua"))()'
--					queue_on_teleport(queued)
--					print("Queued code, "..queued)
--					task.delay(3, function()
--						game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, data.message, player)
--					end)
--				else
--					print('[RTC] Skipped job-id, not waiting for')
--				end
--			end
--		end

--		print("Finished ", lastIndex)

--		lastIndex = #logs
--	end
--end)

--// configs

local Save = Configs:CreateModule("Save", true, function()
	configSavingUI.Enabled = true
	
	local configName = nil
	
	local connection; connection = configSavingUI.Frame.ConfirmButton.MouseButton1Click:Connect(function()
		configName = configSavingUI.Frame.ConfigName.Text
		connection:Disconnect()
	end)
	
	repeat task.wait() until configName
	
	configSavingUI.Enabled = false
	
	local exported = UI:Export()
	
	writefile("Eclipse Hub/"..configName..".json", exported)
end)

local Load = Configs:CreateModule("Load", true, function()
	configSavingUI.Enabled = true

	local configName = nil

	local connection; connection = configSavingUI.Frame.ConfirmButton.MouseButton1Click:Connect(function()
		configName = configSavingUI.Frame.ConfigName.Text
		connection:Disconnect()
	end)

	repeat task.wait() until configName

	configSavingUI.Enabled = false
	
	if not isfile("Eclipse Hub/"..configName..".json") then return end
	
	local contents = readfile("Eclipse Hub/"..configName..".json")
	
	UI:Import(contents)
end)
