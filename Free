--[[
    ███████╗ ██████╗██╗     ██╗██████╗ ███████╗███████╗    ██╗  ██╗██╗   ██╗██████╗
    ██╔════╝██╔════╝██║     ██║██╔══██╗██╔════╝██╔════╝    ██║  ██║██║   ██║██╔══██╗
    █████╗  ██║     ██║     ██║██████╔╝███████╗█████╗      ███████║██║   ██║██████╔╝
    ██╔══╝  ██║     ██║     ██║██╔═══╝ ╚════██║██╔══╝      ██╔══██║██║   ██║██╔══██╗
    ███████╗╚██████╗███████╗██║██║     ███████║███████╗    ██║  ██║╚██████╔╝██████╔╝
    ╚══════╝ ╚═════╝╚══════╝╚═╝╚═╝     ╚══════╝╚══════╝    ╚═╝  ╚═╝ ╚═════╝ ╚═════╝
    
    This script was made by Veylo
    Eclipse Hub - Nice try SKID
]]

--[[
░██████╗░░█████╗░░█████╗░███████╗██╗░░░██╗  ░██████╗██╗░░██╗██╗██████╗░
██╔════╝░██╔══██╗██╔══██╗██╔════╝╚██╗░██╔╝  ██╔════╝██║░██╔╝██║██╔══██╗
██║░░██╗░██║░░██║██║░░██║█████╗░░░╚████╔╝░  ╚█████╗░█████═╝░██║██║░░██║
██║░░╚██╗██║░░██║██║░░██║██╔══╝░░░░╚██╔╝░░  ░╚═══██╗██╔═██╗░██║██║░░██║
╚██████╔╝╚█████╔╝╚█████╔╝██║░░░░░░░░██║░░░  ██████╔╝██║░╚██╗██║██████╔╝
░╚═════╝░░╚════╝░░╚════╝░╚═╝░░░░░░░░╚═╝░░░  ╚═════╝░╚═╝░░╚═╝╚═╝╚═════╝░
]]

if getgenv().eclipsehub then warn("YxuSinx is already executed"); return; end
getgenv().eclipsehub = true;

-- Global variables
local angleTick = 0

loadstring([[
local function LPH_NO_VIRTUALIZE(f) return f; end;
]])();

-- Safely get Players service
local players = game:GetService("Players")
local player

local tweenService = game:GetService("TweenService")
local statsService = game:GetService("Stats")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local starterGui = game:GetService("StarterGui")

-- Get player reference safely
local success, result = pcall(function()
    return players.LocalPlayer
end)
if success then
    player = result
else
    -- Fallback if we can't get the player
    for _, p in pairs(players:GetPlayers()) do
        player = p
        break
    end
end

local mouse
pcall(function()
    mouse = player and player:GetMouse()
end)

local camera = workspace.CurrentCamera
local values = nil

pcall(function()
    values = replicatedStorage:FindFirstChild("Values")
end)

local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = typeof(getexecutorname) == "function" and string.match(getexecutorname(), "Solara") or false
-- Set AC_BYPASS to true for all cases, not just practice mode, to help prevent kicks
local AC_BYPASS = true

-- Define some constants specific to FF2 anti-cheat
local MAX_TELEPORT_DISTANCE = 5 -- Maximum allowable teleport distance to avoid detection
local MAX_VELOCITY_CHANGE = 50 -- Maximum velocity change to avoid detection
local ANTI_CHEAT_DETECTION_THRESHOLD = 1.5 -- Time threshold for suspicious activity
local lastTeleportTime = 0
local lastVelocityChange = 0
local isSafeToModify = true

-- Monitor anti-cheat status
task.spawn(function()
    while true do
        task.wait(0.5)
        local currentTime = os.clock()
        -- Reset flag after a safe period
        if currentTime - lastTeleportTime > ANTI_CHEAT_DETECTION_THRESHOLD and
           currentTime - lastVelocityChange > ANTI_CHEAT_DETECTION_THRESHOLD then
            isSafeToModify = true
        end
    end
end)

-- Safe teleport function that avoids detection
local function safeTeleport(part, targetPosition, instant)
    if not part or not targetPosition then return end

    local currentPosition = part.Position
    local distance = (targetPosition - currentPosition).Magnitude
    local currentTime = os.clock()

    -- If we recently teleported, don't do it again too soon
    if currentTime - lastTeleportTime < ANTI_CHEAT_DETECTION_THRESHOLD then
        isSafeToModify = false
        return
    end

    -- Record the teleport time
    lastTeleportTime = currentTime

    -- Limit teleport distance to avoid detection
    if distance > MAX_TELEPORT_DISTANCE and not instant then
        local direction = (targetPosition - currentPosition).Unit
        targetPosition = currentPosition + direction * MAX_TELEPORT_DISTANCE
    end

    if instant then
        part.CFrame = CFrame.new(targetPosition)
    else
        -- Teleport in small increments
        local steps = math.ceil(distance / 2) -- More steps for longer distances
        steps = math.min(steps, 10) -- Cap at 10 steps

        for i = 1, steps do
            task.wait(0.02) -- Small delay between teleports
            part.CFrame = CFrame.new(currentPosition:Lerp(targetPosition, i/steps))
        end
    end
end

-- Safe velocity change function that avoids detection
local function safeVelocityChange(part, targetVelocity)
    if not part or not targetVelocity then return end

    local currentVelocity = part.Velocity
    local velocityDelta = (targetVelocity - currentVelocity).Magnitude
    local currentTime = os.clock()

    -- If we recently changed velocity, don't do it again too soon
    if currentTime - lastVelocityChange < ANTI_CHEAT_DETECTION_THRESHOLD/2 then
        isSafeToModify = false
        return
    end

    -- Record the velocity change time
    lastVelocityChange = currentTime

    -- Limit velocity change to avoid detection
    if velocityDelta > MAX_VELOCITY_CHANGE then
        local direction = (targetVelocity - currentVelocity).Unit
        targetVelocity = currentVelocity + direction * MAX_VELOCITY_CHANGE
    end

    part.Velocity = targetVelocity
end

local moveToUsing = {}

-- Custom table.find implementation for Lua 5.1
local function table_find(tbl, value)
    if type(tbl) ~= "table" then return nil end
    for i, v in pairs(tbl) do
        if v == value then
            return i
        end
    end
    return nil
end

-- Clean up old moveToUsing times
task.spawn(function()
    while true do
        task.wait(5)
        local currentTime = os.clock()
        for i = #moveToUsing, 1, -1 do
            if currentTime - moveToUsing[i] > 2 then
                table.remove(moveToUsing, i)
            end
        end
    end
end)

-- Track last moveTo time
task.spawn(function()
    -- Check if MoveTo exists before trying to hook it
    local function hookMoveToIfExists(humanoid)
        -- Check if MoveTo is a valid member of the humanoid
        local success, oldMoveTo = pcall(function()
            return typeof(humanoid.MoveTo) == "function" and humanoid.MoveTo or nil
        end)

        if success and oldMoveTo then
            -- Only hook if the function exists
            humanoid.MoveTo = function(self, position, ...)
                table.insert(moveToUsing, os.clock())
                return oldMoveTo(self, position, ...)
            end
        end
    end

    -- Try to hook on current character
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        hookMoveToIfExists(player.Character.Humanoid)
    end

    -- Hook on future characters
    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid")
        hookMoveToIfExists(humanoid)
    end)
end)

if not values or IS_PRACTICE then
    if replicatedStorage:FindFirstChild("Values") then
        replicatedStorage:FindFirstChild("Values"):Destroy()
    end
    values = Instance.new("Folder")
    local status = Instance.new("StringValue")
    status.Name = "Status"
    status.Value = "InPlay"
    status.Parent = values
    values.Parent = replicatedStorage
    values.Name = "Values"
end

if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end
end

-- Additional Anti-cheat bypass setup
-- If we're not in practice mode, add extra protection
if not IS_PRACTICE then
    task.spawn(function()
        local mt = getrawmetatable(game)
        local old = mt.__namecall
        setreadonly(mt, false)
        mt.__namecall = newcclosure(function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            if method == "FireServer" or method == "fireServer" then
                local callName = nil
                pcall(function() callName = args[1] end)
                if typeof(callName) == "string" and string.find(tostring(callName), "AC") then
                    return wait(9e9)
                end
            end
            return old(self, ...)
        end)
        setreadonly(mt, true)
    end)
end

-- Additional anti-cheat bypasses
task.spawn(function()
    -- Hook more game functions that might trigger anti-cheat
    local function hookAntiCheatFunction(funcName)
        local oldFunc
        oldFunc = hookfunction(funcName, function(...)
            local args = {...}
            if string.find(tostring(args[1]), "AC") then
                return wait(9e9)
            end
            return oldFunc(...)
        end)
    end

    -- Try to hook known anti-cheat functions
    pcall(function()
        for _, v in pairs(getgc()) do
            if type(v) == "function" and islclosure(v) then
                local info = debug.getinfo(v)
                if info.name and string.find(info.name:lower(), "cheat") then
                    hookfunction(v, function() return nil end)
                end

                -- Also check for functions that might be used in anti-cheat
                if info.name and (string.find(info.name:lower(), "check") or string.find(info.name:lower(), "verify")) then
                    hookfunction(v, function() return true end)
                end
            end
        end
    end)

    -- Break physics measurements that might be used for anti-cheat
    pcall(function()
        local oldVelocity = Instance.new("Vector3Value")
        oldVelocity.Value = Vector3.new(0, 0, 0)

        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            if not checkcaller() and self:IsA("BasePart") and
               (method == "GetVelocity" or method == "getVelocity") then
                local currentVel = oldNamecall(self, ...)
                -- Smooth out velocity changes to avoid detection
                oldVelocity.Value = oldVelocity.Value:Lerp(currentVel, 0.5)
                return oldVelocity.Value
            end
            return oldNamecall(self, ...)
        end)
    end)
end)

-- Add Football Fusion 2 specific anti-cheat bypass
task.spawn(function()
    -- Monitor key events the game might use for detection
    local remoteFolder = replicatedStorage:FindFirstChild("Remotes")
    if remoteFolder then
        for _, remote in pairs(remoteFolder:GetDescendants()) do
            if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
                -- Block specific anti-cheat related remotes
                if remote.Name:find("AC") or remote.Name:find("Check") or remote.Name:find("Verify") then
                    local oldFireServer = remote.FireServer
                    remote.FireServer = function(...)
                        -- Just return nil for anti-cheat related calls
                        return nil
                    end
                end
            end
        end
    end

    -- Look for specific FF2 anti-cheat modules
    for _, module in pairs(replicatedStorage:GetDescendants()) do
        if module:IsA("ModuleScript") and
          (module.Name:find("Security") or module.Name:find("AntiCheat") or module.Name:find("AC")) then
            local oldRequire = require
            require = function(...)
                local args = {...}
                if args[1] == module then
                    return {
                        Initialize = function() end,
                        Check = function() return true end,
                        Validate = function() return true end,
                        IsValid = function() return true end
                    }
                end
                return oldRequire(...)
            end
        end
    end

    -- Hook key anti-cheat methods
    for _, instance in pairs(game:GetDescendants()) do
        if instance:IsA("LocalScript") and
          (instance.Name:find("Security") or instance.Name:find("AntiCheat") or instance.Name:find("AC")) then
            instance.Disabled = true
        end
    end
end)

local Handshake = replicatedStorage.Remotes.CharacterSoundEvent
local Hooks = {}
local HandshakeInts = {}

LPH_NO_VIRTUALIZE(function()
    for i, v in getgc() do
        if typeof(v) == "function" and islclosure(v) then
            if (#getprotos(v) == 1) and table_find(getconstants(getproto(v, 1)), 4000001) then
                hookfunction(v, function() end)
            end
        end
    end
end)();

Hooks.__namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if not checkcaller() and (self == Handshake) and (Method == "fireServer") and (string.find(Args[1], "AC")) then
        if (#HandshakeInts == 0) then
            HandshakeInts = {table.unpack(Args[2], 2, 18)}
        else
            for i, v in ipairs(HandshakeInts) do
                Args[2][i + 1] = v
            end
            -- Add this return to completely block AC calls
            if not IS_PRACTICE then
                return nil
            end
        end
    end

    return Hooks.__namecall(self, ...)
end))

task.wait(1)

if not isfolder("eclipsehub") then
    makefolder("eclipsehub")
end

local ping = 0
local fps = 0

-- Utility functions
local function getPing()
    return statsService.PerformanceStats.Ping:GetValue()
end

local function getServerPing()
    return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
end

local function findClosestBall()
    local lowestDistance = math.huge
    local nearestBall = nil
    local character = player.Character

    if not character then
        return nil
    end

    for _, ball in pairs(workspace:GetChildren()) do
        if ball.Name == "Football" and ball:IsA("BasePart") then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local distance = (ball.Position - humanoidRootPart.Position).Magnitude
                if distance < lowestDistance then
                    nearestBall = ball
                    lowestDistance = distance
                end
            end
        end
    end

    return nearestBall
end

-- Ball visualization
local part = Instance.new("Part")
part.Transparency = 0.5
part.Anchored = true
part.CanCollide = false
part.CastShadow = false
part.Color = Color3.fromRGB(255, 0, 0)
part.Shape = Enum.PartType.Ball
part.Material = Enum.Material.ForceField
part.Parent = workspace

local function beamProjectile(g, v0, x0, t1)
    local c = 0.5*0.5*0.5
    local p3 = 0.5*g*t1*t1 + v0*t1 + x0
    local p2 = p3 - (g*t1*t1 + v0*t1)/3
    local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2

    local curve0 = (p1 - x0).magnitude
    local curve1 = (p2 - p3).magnitude

    local b = (x0 - p3).unit
    local r1 = (p1 - x0).unit
    local u1 = r1:Cross(b).unit
    local r2 = (p2 - p3).unit
    local u2 = r2:Cross(b).unit
    b = u1:Cross(r1).unit

    local cf1 = CFrame.new(
        x0.x, x0.y, x0.z,
        r1.x, u1.x, b.x,
        r1.y, u1.y, b.y,
        r1.z, u1.z, b.z
    )

    local cf2 = CFrame.new(
        p3.x, p3.y, p3.z,
        r2.x, u2.x, b.x,
        r2.y, u2.y, b.y,
        r2.z, u2.z, b.z
    )

    return curve0, -curve1, cf1, cf2
end

local function getNearestPartToPartFromParts(part, parts)
    local lowestDistance = math.huge
    local nearestPart = nil

    for index, p in pairs(parts) do
        local distance = (part.Position - p.Position).Magnitude

        if distance < lowestDistance then
            nearestPart = p
            lowestDistance = distance
        end
    end

    return nearestPart
end

task.spawn(function()
    while true do
        task.wait(0.1)
        ping = (getPing() + getServerPing()) / 1000
    end
end)

task.spawn(function()
    runService.RenderStepped:Connect(function()
        fps = fps + 1
        task.delay(1, function()
            fps = fps - 1
        end)
    end)
end)

local function findPossessor()
    if not players then return nil end

    for _, plr in pairs(players:GetPlayers()) do
        if plr and plr.Character then
            local character = plr.Character
            if character:FindFirstChildWhichIsA("Tool") then
                return character
            end
        end
    end
    return nil
end

-- Catching features
local fakeBalls = {}
local pullVectoredBalls = {}
local velocity = {}
local isCatching = false

-- Define firetouchinterest with proper fallback
firetouchinterest = firetouchinterest or function() end -- Ensure it exists as a fallback

-- Customize firetouchinterest for Solara
if IS_SOLARA then
    local originalFiretouchinterest = firetouchinterest
    firetouchinterest = function(part2, part1, state)
        if AC_BYPASS then
            part1.CFrame = part2.CFrame
        else
            state = state == 1
            local fakeBall = fakeBalls[part1]
            if not fakeBall then return end

            local direction = (part2.Position - fakeBall.Position).Unit
            local distance = (part2.Position - fakeBall.Position).Magnitude

            for i = 1,5,1 do
                local percentage = i/5 + Random.new():NextNumber(0.01, 0.02)
                part1.CFrame = fakeBall.CFrame + (direction * distance * percentage)
            end
        end
    end
end

local function onCharacterCatching(character)
    if not character then return end

    local arm
    local success = pcall(function()
        arm = character:WaitForChild('Left Arm', 5)
    end)

    if not success or not arm then return end

    arm.ChildAdded:Connect(function(child)
        if not child:IsA("Weld") then return end
        isCatching = true
        task.wait(1.7)
        isCatching = false
    end)
end

workspace.ChildAdded:Connect(function(ball)
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end
    task.wait()

    local lastPosition = ball.Position
    local lastCheck = os.clock()
    local initalVelocity = Vector3.new(0, 0, 0)
    pcall(function()
        if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
            initalVelocity = ball.Velocity
        end
    end)

    if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
        local fakeBall = ball:Clone()
        fakeBall.Name = "FFootball"
        fakeBall.Parent = workspace
        fakeBall.Anchored = true
        fakeBall.CanCollide = false
        local plight = fakeBall:FindFirstChildWhichIsA('PointLight')
        if plight then
            plight:Destroy()
        end
        ball.Transparency = 1
        local spiralDegrees = 0
        fakeBalls[ball] = fakeBall
        task.spawn(function()
            while ball.Parent == workspace do
                local dt = runService.Heartbeat:Wait()
                spiralDegrees = spiralDegrees + 1500 * dt
                initalVelocity = initalVelocity + Vector3.new(0, -28 * dt, 0)
                fakeBall.Position = fakeBall.Position + initalVelocity * dt
                fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)
                local trail = ball:FindFirstChildWhichIsA("Trail")
                if trail then
                    trail.Enabled = false
                end
            end
            fakeBall:Destroy()
        end)
    end

    while ball.Parent do
        task.wait(0.1)

        local t = (os.clock() - lastCheck)

        pcall(function()
            if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                velocity[ball] = (ball.Position - lastPosition) / t
            end
        end)

        lastCheck = os.clock()
        pcall(function()
            if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                lastPosition = ball.Position
            end
        end)
    end
end)

-- Clear tables periodically to prevent memory leaks
task.spawn(function()
    while true do
        task.wait(30) -- Clear every 30 seconds
        for ball, _ in pairs(pullVectoredBalls) do
            if not ball or not ball.Parent then
                pullVectoredBalls[ball] = nil
            end
        end

        for ball, _ in pairs(fakeBalls) do
            if not ball or not ball.Parent then
                if fakeBalls[ball] and fakeBalls[ball].Parent then
                    fakeBalls[ball]:Destroy()
                end
                fakeBalls[ball] = nil
            end
        end

        for ball, _ in pairs(velocity) do
            if not ball or not ball.Parent then
                velocity[ball] = nil
            end
        end
    end
end)

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local function safeIndex(t, index)
    if type(t) ~= "table" and type(t) ~= "userdata" then
        return nil
    end

    local success, result = pcall(function()
        return t[index]
    end)

    if success then
        return result
    else
        return nil
    end
end

Fluent:Notify({
    Title = "YxuSinX",
    Content = "Successfully loaded FF2 script",
    Duration = 5
})

-- ========================= DEFINE WINDOW AND TABS =========================

local Window = Fluent:CreateWindow({
    Title = "YxuSinX - Football Fusion 2",
    SubTitle = "by Veylo",
    TabWidth = 160,
    Size = UDim2.fromOffset(595, 365),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl,
    CanResize = true,
    ScrollSpeed = 30,
    ScrollingEnabled = true
})

local Tabs = {
    Catching = Window:AddTab({ Title = "Catching", Icon = "radio", ScrollingEnabled = true }),
    Physics = Window:AddTab({ Title = "Physics", Icon = "rocket", ScrollingEnabled = true }),
    Auto = Window:AddTab({ Title = "Auto", Icon = "bot", ScrollingEnabled = true }),
    Throwing = Window:AddTab({ Title = "Throwing", Icon = "send", ScrollingEnabled = true }),
    Player = Window:AddTab({ Title = "Player", Icon = "user", ScrollingEnabled = true }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings", ScrollingEnabled = true })
}

local Options = Fluent.Options

-- ========================= CATCHING TAB FEATURES =========================

local MagnetsToggle = Tabs.Catching:AddToggle("Magnets", {
    Title = "Magnets",
    Default = false,
    Description = "Helps you catch the ball"
})

local MagnetsType = Tabs.Catching:AddDropdown("MagnetsType", {
    Title = "Type",
    Values = {"Blatant", "Legit", "League"},
    Default = "League",
    Description = "How obvious the magnets behavior is"
})

local MagnetsCustomRadius = Tabs.Catching:AddSlider("MagnetsCustomRadius", {
    Title = "Radius",
    Description = "Radius for the Magnets",
    Default = 35,
    Min = 0,
    Max = 70,
    Rounding = 1
})

local ShowMagHitbox = Tabs.Catching:AddToggle("ShowMagHitbox", {
    Title = "Visualise Hitbox",
    Default = false,
    Description = "Displays the mag hitbox"
})

local PullVectorToggle = Tabs.Catching:AddToggle("PullVector", {
    Title = "Pull Vector",
    Default = false,
    Description = "Pulls you towards the ball"
})

local PullVectorDistance = Tabs.Catching:AddSlider("PullVectorDistance", {
    Title = "Distance",
    Description = "Maximum distance to activate pull",
    Default = 50,
    Min = 0,
    Max = 100,
    Rounding = 1
})

local PullVectorType = Tabs.Catching:AddDropdown("PullVectorType", {
    Title = "Type",
    Values = {"Glide", "Teleport"},
    Default = "Glide"
})

local PullVectorPower = Tabs.Catching:AddSlider("PullVectorPower", {
    Title = "Power",
    Description = "Strength of the pull effect",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 1
})

-- Magnet Hitbox visualization part (match Luarmor.lua)
local magnetHitboxPart = Instance.new("Part")
magnetHitboxPart.Anchored = true
magnetHitboxPart.CanCollide = false
magnetHitboxPart.Transparency = 0.6  -- Changed to match Luarmor
magnetHitboxPart.Color = Color3.fromRGB(255, 0, 0)  -- Changed from light blue to red
magnetHitboxPart.Material = Enum.Material.ForceField  -- Changed to match Luarmor
magnetHitboxPart.Shape = Enum.PartType.Ball
magnetHitboxPart.Parent = nil  -- Start hidden (nil parent)
magnetHitboxPart.Size = Vector3.new(35,35,35)  -- Default size from Luarmor

-- Update magnet hitbox visibility and size
local function updateMagnetHitbox(ball, radius)
    if ShowMagHitbox and ShowMagHitbox.Value and ball then
        magnetHitboxPart.Size = Vector3.new(radius, radius, radius)
        magnetHitboxPart.Position = ball.Position
        magnetHitboxPart.Transparency = 0.6
        magnetHitboxPart.Parent = workspace
    else
        magnetHitboxPart.Parent = nil
    end
end

-- Main loop to apply magnets and pull vector (Luarmor-style magnets implementation)
task.spawn(function()
    while true do
        task.wait(0.1)
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            -- skip
        else
            local hrp = player.Character.HumanoidRootPart

            -- Only run modifications if it's safe (to avoid anti-cheat detection)
            if isSafeToModify then
                if MagnetsToggle and MagnetsToggle.Value then
                    local ball = findClosestBall()
                    if not ball then
                        magnetHitboxPart.Parent = nil
                        goto continue_main_loop
                    end

                    local character = player.Character
                    if not character then
                        magnetHitboxPart.Parent = nil
                        goto continue_main_loop
                    end

                    -- Get catch parts just like in Luarmor
                    local catchLeft = character:FindFirstChild("CatchLeft")
                    local catchRight = character:FindFirstChild("CatchRight")

                    if not catchLeft or not catchRight then
                        magnetHitboxPart.Parent = nil
                        goto continue_main_loop
                    end

                    -- Get nearest catch part to the ball
                    local catchPart = getNearestPartToPartFromParts(ball, {catchLeft, catchRight})

                    if not catchPart then
                        magnetHitboxPart.Parent = nil
                        goto continue_main_loop
                    end

                    if not velocity[ball] then
                        magnetHitboxPart.Parent = nil
                        goto continue_main_loop
                    end

                    -- Check for "LegitV2" mode and convert to "League" just like in Luarmor
                    if MagnetsType and MagnetsType.Value == "LegitV2" then
                        if MagnetsType.SetValue then
                            MagnetsType:SetValue("League")
                        end
                    end

                    -- League mode implementation (from Luarmor)
                    if MagnetsType and MagnetsType.Value == "League" then
                        local fakeBallToUse = fakeBalls[ball] or ball
                        local predictedPosition = fakeBallToUse.Position + (velocity[ball] * ping)
                        local distance = (catchPart.Position - predictedPosition).Magnitude
                        local radius = MagnetsCustomRadius and MagnetsCustomRadius.Value or 35

                        -- Update the hitbox visualization
                        updateMagnetHitbox(fakeBallToUse, radius)

                        -- Only apply magnet effect if within range
                        if distance <= radius and math.random(1, 3) == 1 then -- Randomize to avoid detection
                            -- Only use firetouchinterest if it's very safe (low chance of detection)
                            if math.random(1, 5) == 1 and os.clock() - lastTeleportTime > ANTI_CHEAT_DETECTION_THRESHOLD * 2 then
                                pcall(function()
                                    firetouchinterest(catchPart, ball, 0)
                                    firetouchinterest(catchPart, ball, 1)
                                end)
                            end
                        end
                    else
                        -- Blatant/Legit mode implementation (from Luarmor)
                        local distance = (catchPart.Position - ball.Position).Magnitude
                        local radius = (MagnetsType and MagnetsType.Value == "Blatant" and 50 or 6)

                        -- Update the hitbox visualization
                        updateMagnetHitbox((fakeBalls[ball] or ball), radius)

                        -- SOLARA specific check from Luarmor
                        if not isCatching and IS_SOLARA then
                            goto continue_main_loop
                        end

                        -- Only apply magnet effect if within range
                        if distance < radius and math.random(1, 3) == 1 then -- Randomize to avoid detection
                            -- Only use firetouchinterest if it's very safe (low chance of detection)
                            if math.random(1, 5) == 1 and os.clock() - lastTeleportTime > ANTI_CHEAT_DETECTION_THRESHOLD * 2 then
                                pcall(function()
                                    firetouchinterest(catchPart, ball, 0)
                                    firetouchinterest(catchPart, ball, 1)
                                end)
                            end
                        end
                    end
                else
                    -- Hide hitbox if magnets are disabled
                    magnetHitboxPart.Parent = nil
                end

                ::continue_main_loop::

                -- Make the pull vector even more subtle
                if PullVectorToggle and PullVectorToggle.Value then
                    local maxDist = PullVectorDistance and PullVectorDistance.Value or 30
                    local power = PullVectorPower and PullVectorPower.Value or 50
                    local pType = PullVectorType and PullVectorType.Value or "Glide"

                    -- Process only one ball per tick
                    local closestBall = findClosestBall()

                    if closestBall then
                        local dist = (closestBall.Position - hrp.Position).Magnitude
                        if dist <= maxDist then
                            -- Even lower chance to apply velocity changes
                            if math.random(1, 10) == 1 then -- 10% chance each frame
                                local direction = (hrp.Position - closestBall.Position).Unit
                                local forceMagnitude

                                if pType == "Glide" then
                                    forceMagnitude = power * (0.3 + (math.random() * 0.2))
                                elseif pType == "Teleport" then
                                    forceMagnitude = power * (0.3 + (math.random() * 0.3))
                                else
                                    forceMagnitude = power * (0.3 + (math.random() * 0.2))
                                end

                                -- Apply a very small force to avoid detection
                                safeVelocityChange(closestBall, closestBall.Velocity + direction * forceMagnitude)
                            end
                        end
                    end
                end
            end
        end
    end
end)

-- Pull vector functionality and character movement physics (Lua 5.1 compliant)
task.spawn(function()
    while true do
        task.wait()
        local ball = findClosestBall()
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        local skip = false
        if not ball then
            skip = true
            -- Hide hitbox if no ball found
            magnetHitboxPart.Parent = nil
        end
        if not ball and not skip and not ball:FindFirstChildWhichIsA("Trail") then skip = true end
        if not character and not skip or not humanoidRootPart and not skip then skip = true end
        if not PullVectorToggle or not PullVectorToggle.Value and not skip then skip = true end
        if pullVectoredBalls[ball] and not skip then skip = true end
        if ball and not skip and ball.Anchored then skip = true end

        if not skip then
            local distance = (humanoidRootPart.Position - ball.Position).Magnitude

            if distance <= (PullVectorDistance and PullVectorDistance.Value or 50) then
                local direction = (ball.Position - humanoidRootPart.Position).Unit

                if PullVectorType and PullVectorType.Value == "Teleport" then
                    pullVectoredBalls[ball] = true
                    -- Make teleportation more subtle with a smaller distance
                    local dist = 3 + ((PullVectorPower and PullVectorPower.Value or 3 - 1) * 2) -- Reduced distance
                    local targetPosition = humanoidRootPart.Position + direction * dist

                    -- Use our anti-cheat safe teleport function
                    safeTeleport(humanoidRootPart, targetPosition, false)
                else
                    -- Apply velocity changes in a way that's harder to detect
                    pcall(function()
                        if humanoidRootPart and typeof(humanoidRootPart) == "Instance" and humanoidRootPart:IsA("BasePart") then
                            -- Gradually apply velocity changes over multiple frames
                            local targetVelocity = direction * (PullVectorPower and PullVectorPower.Value or 3) * 10 -- Reduced multiplier
                            local currentVelocity = humanoidRootPart.AssemblyLinearVelocity

                            -- Apply only a portion of the velocity change to make it more natural
                            humanoidRootPart.AssemblyLinearVelocity = currentVelocity:Lerp(targetVelocity, 0.3)
                        end
                    end)
                end
            end
        end
    end
end)

local QuickTPToggle = Tabs.Physics:AddToggle("QuickTP", {
    Title = "Quick TP",
    Default = false,
    Description = "Teleport quickly in the direction you're moving"
})

local QuickTPSpeed = Tabs.Physics:AddSlider("QuickTPSpeed", {
    Title = "Speed",
    Description = "QuickTP speed multiplier",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 1
})

local QuickTPBind = Tabs.Physics:AddKeybind("QuickTPBind", {
    Title = "Keybind",
    Default = "F",
    Mode = "Toggle",
    Description = "Key to activate Quick TP"
})

local ClickTackleAimbotToggle = Tabs.Physics:AddToggle("ClickTackleAimbot", {
    Title = "Click Tackle Aimbot",
    Default = false,
    Description = "Teleport to the ball carrier when clicking"
})

local ClickTackleAimbotDistance = Tabs.Physics:AddSlider("ClickTackleAimbotDistance", {
    Title = "Distance",
    Description = "Maximum teleport distance",
    Default = 7,
    Min = 0,
    Max = 15,
    Rounding = 1
})

local AntiJamToggle = Tabs.Physics:AddToggle("AntiJam", {
    Title = "Anti Jam",
    Default = false,
    Description = "Prevents you from getting jammed"
})

local AntiBlockToggle = Tabs.Physics:AddToggle("AntiBlock", {
    Title = "Anti Block",
    Default = false,
    Description = "Prevents players from blocking you"
})

local VisualizeBallPathToggle = Tabs.Physics:AddToggle("VisualizeBallPath", {
    Title = "Visualize Ball Path",
    Default = false,
    Description = "Shows the path of the ball"
})

local NoJumpCooldownToggle = Tabs.Physics:AddToggle("NoJumpCooldown", {
    Title = "No Jump Cooldown",
    Default = false,
    Description = "Removes the cooldown between jumps"
})

local NoFreezeToggle = Tabs.Physics:AddToggle("NoFreeze", {
    Title = "No Freeze",
    Default = false,
    Description = "Prevents movement freezing"
})

local OptimalJumpToggle = Tabs.Physics:AddToggle("OptimalJump", {
    Title = "Optimal Jump",
    Default = false,
    Description = "Shows the best position to jump for catches"
})

local OptimalJumpType = Tabs.Physics:AddDropdown("OptimalJumpType", {
    Title = "Type",
    Values = {"Jump", "Dive"},
    Default = "Jump",
    Description = "Jump or dive indicator"
})

local NoBallTrailToggle = Tabs.Physics:AddToggle("NoBallTrail", {
    Title = "No Ball Trail",
    Default = false,
    Description = "Removes the trail behind the ball"
})

local BigHeadToggle = Tabs.Physics:AddToggle("BigHead", {
    Title = "Big Head",
    Default = false,
    Description = "Increases the size of player heads"
})

local BigHeadSize = Tabs.Physics:AddSlider("BigHeadSize", {
    Title = "Size",
    Description = "Head size multiplier",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 1
})

-- ========================= PLAYER TAB FEATURES =========================

local SpeedToggle = Tabs.Player:AddToggle("Speed", {
    Title = "Speed",
    Default = false,
    Description = "Increases your movement speed"
})

local SpeedValue = Tabs.Player:AddSlider("SpeedValue", {
    Title = "Speed",
    Description = "Speed multiplier",
    Default = 22,
    Min = 20,
    Max = 23,
    Rounding = 1,
    Callback = function(Value)
        if Options.Speed and Options.Speed.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = Value
            end
        end
    end
})

local JumpPowerToggle = Tabs.Player:AddToggle("JumpPower", {
    Title = "Jump Power",
    Default = false,
    Description = "Increases your jump height"
})

local JumpPowerValue = Tabs.Player:AddSlider("JumpPowerValue", {
    Title = "Power",
    Description = "Jump power multiplier",
    Default = 60,
    Min = 50,
    Max = 70,
    Rounding = 1,
    Callback = function(Value)
        if Options.JumpPower and Options.JumpPower.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                if AC_BYPASS then
                    humanoid.JumpPower = Value
                end
            end
        end
    end
})

local AngleAssistToggle = Tabs.Player:AddToggle("AngleAssist", {
    Title = "Angle Assist",
    Default = false,
    Description = "Boosts your angles"
})

local AngleAssistJP = Tabs.Player:AddSlider("AngleAssistJP", {
    Title = "JP",
    Description = "Jump power for angle assist",
    Default = 60,
    Min = 50,
    Max = 70,
    Rounding = 1,
    Callback = function(Value)
        if Options.AngleAssist and Options.AngleAssist.Value then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                humanoid.JumpPower = Value
            end
        end
    end
})

-- ========================= AUTO TAB FEATURES =========================

local AutoCapToggle = Tabs.Auto:AddToggle("AutoCap", {
    Title = "Auto Cap",
    Default = false,
    Description = "Makes you auto win the race for captain"
})

local AutoCapEnabled = Tabs.Auto:AddToggle("AutoCapEnabled", {
    Title = "Enabled",
    Default = false,
    Description = "Enable/disable auto cap feature"
})

-- ========================= THROWING TAB FEATURES =========================

local QBAimbot = Tabs.Throwing:AddToggle("QBAimbot", {
    Title = "QB Aimbot",
    Default = false,
    Description = "Makes your throws more accurate"
})

Tabs.Throwing:AddParagraph({
    Title = "Coming Soon",
    Content = "QB Aimbot feature is currently in development."
})

-- ========================= SETTINGS TAB BUTTONS =========================

Tabs.Settings:AddButton({
    Title = "Save Config",
    Description = "Save current configuration",
    Callback = function()
        Fluent:Notify({
            Title = "Config System",
            Content = "Enter a name for your config in the prompt",
            Duration = 3
        })

        local configName = nil
        local success, result = pcall(function()
            return Fluent:Prompt({
                Title = "Save Configuration",
                Content = "Enter a name for your configuration",
                TextBoxValue = "",
                Buttons = {
                    {
                        Title = "Save",
                        Callback = function(textBoxValue)
                            configName = textBoxValue
                            return true
                        end
                    },
                    {
                        Title = "Cancel",
                        Callback = function()
                            return false
                        end
                    }
                }
            })
        end)

        if success and result and configName and #configName > 0 then
            local exported = SaveManager:SaveConfiguration(configName)
            if exported then
                Fluent:Notify({
                    Title = "Config System",
                    Content = "Configuration saved as " .. configName,
                    Duration = 3
                })
            end
        end
    end
})

Tabs.Settings:AddButton({
    Title = "Load Config",
    Description = "Load a saved configuration",
    Callback = function()
        SaveManager:LoadConfiguration()
    end
})

-- Initialize default values for options
for _, option in pairs(Options) do
    if type(option) == "table" and option.SetValue then
        local success, err = pcall(function()
            if option.Value == nil then
                option:SetValue(option.Default)
            end
        end)
    end
end

-- ========================= EVENT CONNECTIONS AND LOGIC =========================

local quickTPCooldown = os.clock()

userInputService.InputBegan:Connect(function(input, gp)
    if gp then return end

    if not Options.QuickTPBind or not Options.QuickTPBind.Value then return end

    if input.KeyCode ~= Options.QuickTPBind.Value then return end

    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not Options.QuickTP or not Options.QuickTP.Value then return end
    if not character or not humanoidRootPart or not humanoid then return end
    if (os.clock() - quickTPCooldown) < 0.1 then return end

    -- Use our safe teleport function instead of direct CFrame manipulation
    local speed = 0.5 + ((Options.QuickTPSpeed and Options.QuickTPSpeed.Value or 3) / 8) -- Reduced speed
    local targetPosition = humanoidRootPart.Position + humanoid.MoveDirection * speed

    -- Use our anti-cheat safe teleport function
    safeTeleport(humanoidRootPart, targetPosition, false)

    quickTPCooldown = os.clock()
end)

-- ========================= CLICK TACKLE AIMBOT FEATURE =========================

mouse.Button1Down:Connect(function()
    if not Options.ClickTackleAimbot or not Options.ClickTackleAimbot.Value then return end

    local possessor = findPossessor()
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not character or not humanoidRootPart then return end
    if not possessor or not possessor:FindFirstChild("HumanoidRootPart") then return end

    local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
    if not Options.ClickTackleAimbotDistance or distance > Options.ClickTackleAimbotDistance.Value then return end

    -- Use our safe teleport function instead of direct CFrame manipulation
    local targetPosition = possessor.HumanoidRootPart.Position

    -- Use our anti-cheat safe teleport function
    safeTeleport(humanoidRootPart, targetPosition, false)
end)

local boundaries = {}

if not IS_PRACTICE then
    for index, part in pairs(workspace.Models.Boundaries:GetChildren()) do
        boundaries[#boundaries + 1] = part
    end
end

if firetouchinterest and not IS_SOLARA then
    local TackleExtenderToggle = Tabs.Physics:AddToggle("TackleExtender", {
        Title = "Tackle Extender",
        Default = false,
        Description = "Extends your tackle reach"
    })

    local TackleExtenderRadius = Tabs.Physics:AddSlider("TackleExtenderRadius", {
        Title = "Radius",
        Description = "Tackle extension distance",
        Default = 5,
        Min = 0,
        Max = 10,
        Rounding = 1
    })

    task.spawn(function()
        while true do
            task.wait()

            local possessor = findPossessor()
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")

            local skip = false
            if not hrp then skip = true end
            if not possessor and not skip then skip = true end
            if not Options.TackleExtender or not Options.TackleExtender.Value and not skip then skip = true end

            if not skip then
                local distance = (hrp.Position - possessor.HumanoidRootPart.Position).Magnitude

                if distance <= (Options.TackleExtenderRadius and Options.TackleExtenderRadius.Value or 5) then
                    for index, part in pairs(possessor:GetChildren()) do
                        local partSkip = false
                        if not part:IsA("BasePart") then partSkip = true end
                        if not character:FindFirstChild(part.Name) and not partSkip then partSkip = true end

                        if not partSkip then
                            firetouchinterest(character:FindFirstChild(part.Name), part, 0)
                            firetouchinterest(character:FindFirstChild(part.Name), part, 1)
                        end
                    end
                end
            end
        end
    end)
end

if AC_BYPASS then
    local BlockExtenderToggle = Tabs.Physics:AddToggle("BlockExtender", {
        Title = "Block Extender",
        Default = false,
        Description = "Extends your blocking range"
    })

    local BlockExtenderRange = Tabs.Physics:AddSlider("BlockExtenderRange", {
        Title = "Range",
        Description = "Block extension distance",
        Default = 10,
        Min = 1,
        Max = 20,
        Rounding = 1
    })

    local BlockExtenderTransparency = Tabs.Physics:AddSlider("BlockExtenderTransparency", {
        Title = "Transparency",
        Description = "Visual transparency of block zone",
        Default = 1,
        Min = 0,
        Max = 1,
        Rounding = 1
    })

    local flying = false
    local flySpeed = 1

    local FlyToggle = Tabs.Physics:AddToggle("Fly", {
        Title = "Fly",
        Default = false,
        Description = "Enables flight mode"
    })

    FlyToggle:OnChanged(function(Value)
        flying = Value

        if Value then
            player.Character.Humanoid.PlatformStand = true
            local bodyVelocity = Instance.new("BodyVelocity", player.Character.HumanoidRootPart)
            local camera = workspace.CurrentCamera
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            local bodyGyro = Instance.new("BodyGyro", player.Character.HumanoidRootPart)
            bodyGyro.P = 15000
            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)

            task.spawn(function()
                while flying do
                    runService.Stepped:wait()
                    local speed = 11 + (flySpeed * 2.5)
                    local endPos = camera.CFrame.Position + camera.CFrame.LookVector * 500
                    bodyGyro.CFrame = CFrame.new(player.Character.HumanoidRootPart.Position, endPos)
                    local velocity = Vector3.new(0, 0, 0)

                    if not userInputService:GetFocusedTextBox() then
                        if userInputService:IsKeyDown(Enum.KeyCode.W) then
                            velocity = velocity + camera.CFrame.LookVector * speed
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.S) then
                            velocity = velocity + camera.CFrame.LookVector * -speed
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.A) then
                            velocity = velocity + player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(-speed, 0, 0))
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.D) then
                            velocity = velocity + player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(speed, 0, 0))
                        end
                    end

                    if player.Character.Humanoid.Health <= 0 then
                        flying = false
                    end

                    bodyVelocity.Velocity = velocity
                    task.wait()
                end

                player.Character.Humanoid.PlatformStand = false
                bodyGyro:Destroy()
                bodyVelocity:Destroy()
            end)
        end
    end)

    local FlySpeedSlider = Tabs.Physics:AddSlider("FlySpeed", {
        Title = "Speed",
        Description = "Flying speed multiplier",
        Default = 3,
        Min = 1,
        Max = IS_PRACTICE and 20 or 5,
        Rounding = 1
    })

    FlySpeedSlider:OnChanged(function(Value)
        flySpeed = Value
    end)

    task.spawn(function()
        while true do
            task.wait()

            local character = player.Character
            local blockPart = character and character:FindFirstChild("BlockPart")

            local continue = false
            if not blockPart then continue = true end

            if not continue then
                blockPart.Size = BlockExtenderToggle.Value and Vector3.new(BlockExtenderRange.Value, BlockExtenderRange.Value, BlockExtenderRange.Value) or Vector3.new(0.75, 5, 1.5)
                blockPart.Transparency = BlockExtenderToggle.Value and BlockExtenderTransparency.Value or 1
            end
        end
    end)
end

local function onCharacterPhysics(char)
    local humanoid = char:WaitForChild("Humanoid")

    char.DescendantAdded:Connect(function(v)
        task.wait()
        if v.Name:match("FFmover") and Options.AntiBlock and Options.AntiBlock.Value then
            v:Destroy()
        end
    end)

    task.spawn(function()
        while true do
            task.wait()
            if Options.NoJumpCooldown and Options.NoJumpCooldown.Value then
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end

            local torso = char:FindFirstChild("Torso")
            local head = char:FindFirstChild("Head")

            if not torso or not head then break end

            if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
                torso.CanCollide = not (Options.AntiJam and Options.AntiJam.Value)
                head.CanCollide = not (Options.AntiJam and Options.AntiJam.Value)
            else
                torso.CanCollide = true
                head.CanCollide = true
            end
        end
    end)
end

task.spawn(function()
    local function applyChanges(character)
        local head = character and character:FindFirstChild("Head")
        local mesh = head and head:FindFirstChildWhichIsA("SpecialMesh")

        if not mesh then return end

        if Options.BigHead and Options.BigHead.Value then
            mesh.MeshType = Enum.MeshType.Sphere
            head.Size = Vector3.new(Options.BigHeadSize and Options.BigHeadSize.Value or 3, 1, Options.BigHeadSize and Options.BigHeadSize.Value or 3)
        else
            mesh.MeshType = Enum.MeshType.Head
            head.Size = Vector3.new(2, 1, 1)
        end
    end

    while true do
        task.wait()

        for index, plr in pairs(players:GetPlayers()) do
            if plr ~= players.LocalPlayer then
                applyChanges(plr.Character)
            end
        end
    end
end)

workspace.ChildAdded:Connect(function(ball)
    task.wait()
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end

    if Options.NoBallTrail and Options.NoBallTrail.Value and ball:FindFirstChildWhichIsA("Trail") then
        ball:FindFirstChildWhichIsA("Trail").Enabled = false
    end

    task.spawn(function()
        if not Options.OptimalJump or not Options.OptimalJump.Value then return end
        local initalVelocity = Vector3.new(0, 0, 0)
        pcall(function()
            if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                initalVelocity = ball.Velocity
            end
        end)
        local optimalPosition = Vector3.zero

        local currentPosition = ball.Position

        local t = 0

        while true do
            t = t + 0.05
            initalVelocity = initalVelocity + Vector3.new(0, -28 * 0.05, 0)
            currentPosition = currentPosition + initalVelocity * 0.05
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Models")}
            raycastParams.FilterType = Enum.RaycastFilterType.Include

            local ray = workspace:Raycast(currentPosition, Vector3.new(0, Options.OptimalJumpType and Options.OptimalJumpType.Value == "Jump" and -13 or -15, 0), raycastParams)
            local antiCrashRay = workspace:Raycast(currentPosition, Vector3.new(0, -500, 0), raycastParams)

            if ray and t > 0.75 then
                optimalPosition = ray.Position + Vector3.new(0, 2, 0)
                break
            end

            if not antiCrashRay then
                optimalPosition = currentPosition
                break
            end
        end

        local optPart = Instance.new("Part")
        optPart.Anchored = true
        optPart.Material = Enum.Material.Neon
        optPart.Size = Vector3.new(1.5, 1.5, 1.5)
        optPart.Position = optimalPosition
        optPart.CanCollide = false
        optPart.Color = Color3.fromRGB(255, 0, 0)
        optPart.Parent = workspace

        repeat task.wait() until ball.Parent ~= workspace

        optPart:Destroy()
    end)

    task.spawn(function()
        if not Options.VisualizeBallPath or not Options.VisualizeBallPath.Value then return end
        local initalVelocity = Vector3.new(0, 0, 0)
        pcall(function()
            if ball and typeof(ball) == "Instance" and ball:IsA("BasePart") then
                initalVelocity = ball.Velocity
            end
        end)
        local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
        a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

        local beam = Instance.new("Beam", workspace.Terrain)
        beam.Attachment0 = a0
        beam.Attachment1 = a1
        beam.Segments = 500
        beam.Width0 = 0.5
        beam.Width1 = 0.5
        beam.Transparency = NumberSequence.new(0)
        beam.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))

        local g = Vector3.new(0, -28 ,0)
        local x0 = ball.Position
        local v0 = initalVelocity

        local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, 5)

        beam.CurveSize0 = curve0
        beam.CurveSize1 = curve1
        a0.CFrame = a0.Parent.CFrame:inverse() * cf1
        a1.CFrame = a1.Parent.CFrame:inverse() * cf2

        repeat task.wait() until ball.Parent ~= workspace

        beam:Destroy()
    end)
end)

player.CharacterAdded:Connect(function(character)
    onCharacterCatching(character)
    onCharacterPhysics(character)
end)

if player.Character then
    onCharacterCatching(player.Character)
    onCharacterPhysics(player.Character)
end

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})

InterfaceManager:SetFolder("EclipseHub")
SaveManager:SetFolder("EclipseHub/ff2")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

Fluent:Notify({
    Title = "Eclipse Hub",
    Content = "Script successfully loaded. Enjoy",
    Duration = 7
})

-- ========================= PLAYER MOVEMENT IMPLEMENTATIONS =========================

local function onCharacterMovement(character)
    local humanoid = character:WaitForChild("Humanoid")
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    task.spawn(function()
        while AC_BYPASS and humanoid.Parent do
            task.wait(.1)
            humanoid.JumpPower = Options.JumpPower and Options.JumpPower.Value and Options.JumpPowerValue.Value or 50
        end
    end)

    humanoid.Jumping:Connect(function()
        if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
        if AC_BYPASS then return end
        task.wait(0.05)
        if Options.JumpPower and Options.JumpPower.Value then
            pcall(function()
                if humanoidRootPart and typeof(humanoidRootPart) == "Instance" and humanoidRootPart:IsA("BasePart") then
                    local jumpBoost = Options.JumpPowerValue.Value - 50
                    humanoidRootPart:ApplyImpulse(Vector3.new(0, jumpBoost * humanoidRootPart.AssemblyMass, 0))
                end
            end)
        end
    end)
end

onCharacterMovement(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterMovement)

task.spawn(function()
    angleTick = os.clock()
    local oldLookVector = Vector3.new(0, 0, 0)

    local shiftLockEnabled = false
    local lastEnabled = false

    local function hookCharacter(character)
        local humanoid = character:WaitForChild("Humanoid")
        local hrp = character:WaitForChild("HumanoidRootPart")

        humanoid.Jumping:Connect(function()
            if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
            if os.clock() - angleTick > 0.2 then return end
            if not Options.AngleAssist or not Options.AngleAssist.Value then return end

            if AC_BYPASS then return end

            task.wait(0.05)
            pcall(function()
                if hrp and typeof(hrp) == "Instance" and hrp:IsA("BasePart") and Options.AngleAssistJP and Options.AngleAssistJP.Value then
                    hrp:ApplyImpulse(Vector3.new(0, (Options.AngleAssistJP.Value - 50) * hrp.AssemblyMass, 0))
                end
            end)
        end)
    end

    hookCharacter(player.Character or player.CharacterAdded:Wait())
    player.CharacterAdded:Connect(hookCharacter)

    userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
        if userInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
            shiftLockEnabled = true
        else
            shiftLockEnabled = false
        end
    end)

    while true do
        task.wait()
        local character = player.Character
        if not character then
            -- continue
        else
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                -- continue
            else
                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then
                    -- continue
                else
                    local lookVector = hrp.CFrame.LookVector
                    local difference = (oldLookVector - lookVector).Magnitude

                    if not shiftLockEnabled and lastEnabled then
                        angleTick = os.clock()
                    end

                    -- Fix for Lua 5.1: no +=, so do explicit addition
                    if AC_BYPASS then
                        if (os.clock() - angleTick < 0.2) and Options.AngleAssist and Options.AngleAssist.Value then
                            humanoid.JumpPower = (Options.JumpPower and Options.JumpPower.Value and Options.JumpPowerValue.Value or 50) + (Options.AngleAssistJP and Options.AngleAssistJP.Value - 50 or 0)
                        elseif not Options.AngleAssist or not Options.AngleAssist.Value then
                            humanoid.JumpPower = (Options.JumpPower and Options.JumpPower.Value and Options.JumpPowerValue.Value or 50)
                        end
                    end

                    oldLookVector = hrp.CFrame.LookVector
                    lastEnabled = shiftLockEnabled
                end
            end
        end
    end
end)

runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not character or not humanoid then return end
    if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
    if humanoid.WalkSpeed == 0 and not (Options.NoFreeze and Options.NoFreeze.Value) then return end
    if not character:FindFirstChild("HumanoidRootPart") then return end

    local moveDirection

    -- Check if we have any recorded moveTo usage and it's recent
    local hasMoveToData = moveToUsing and type(moveToUsing) == "table" and #moveToUsing > 0
    local isRecentMoveTo = hasMoveToData and (os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5

    if isRecentMoveTo then
        -- Safely try to use WalkToPoint if it exists
        pcall(function()
            local hasWalkToPoint = humanoid and typeof(humanoid.WalkToPoint) == "Vector3"
            local hasHumanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            local hasValidPosition = hasHumanoidRootPart and typeof(character.HumanoidRootPart.Position) == "Vector3"

            if hasWalkToPoint and hasHumanoidRootPart and hasValidPosition then
                local direction = (humanoid.WalkToPoint - character.HumanoidRootPart.Position)
                if direction.Magnitude > 0 then
                    moveDirection = direction.Unit
                end
            end
        end)
    end

    if not moveDirection then
        moveDirection = humanoid.MoveDirection
    end

    local currentVel = Vector3.new(0, 0, 0)
    pcall(function()
        if character and character:FindFirstChild("HumanoidRootPart") and
           typeof(character.HumanoidRootPart) == "Instance" and
           character.HumanoidRootPart:IsA("BasePart") then
            currentVel = character.HumanoidRootPart:GetVelocity()
        end
    end)

    if (Options.Speed and Options.Speed.Value) or (Options.NoFreeze and Options.NoFreeze.Value) then
        local speedVal = 20

        if Options.Speed and Options.Speed.Value and Options.SpeedValue then
            if type(Options.SpeedValue.Value) == "number" and Options.SpeedValue.Value > 20 then
                speedVal = Options.SpeedValue.Value
            end
        end

        pcall(function()
            if character and character:FindFirstChild("HumanoidRootPart") and
               typeof(character.HumanoidRootPart) == "Instance" and
               character.HumanoidRootPart:IsA("BasePart") then
                local newVelocity = Vector3.new(
                    moveDirection.X * speedVal,
                    currentVel.Y,
                    moveDirection.Z * speedVal
                )
                character.HumanoidRootPart:SetVelocity(newVelocity)
            end
        end)
    end
end)

task.spawn(function()
    while true do
        task.wait(0.5)

        if safeIndex(Options.Speed, "Value") and safeIndex(Options.SpeedValue, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                if AC_BYPASS then
                    humanoid.WalkSpeed = Options.SpeedValue.Value
                end
            end
        end

        if safeIndex(Options.JumpPower, "Value") and safeIndex(Options.JumpPowerValue, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                humanoid.JumpPower = Options.JumpPowerValue.Value
            end
        end

        if safeIndex(Options.AngleAssist, "Value") and safeIndex(Options.AngleAssistJP, "Value") then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid and AC_BYPASS then
                if os.clock() - (angleTick or 0) < 0.2 then
                    humanoid.JumpPower = Options.AngleAssistJP.Value
                end
            end
        end
    end
end)

-- ========================= AUTO CAP IMPLEMENTATION =========================

local finishLine = not IS_PRACTICE and workspace.Models.LockerRoomA.FinishLine or Instance.new('Part')

task.spawn(function()
    while true do
        task.wait()
        if not safeIndex(Options.AutoCap, "Value") or not safeIndex(Options.AutoCapEnabled, "Value") then
            -- continue
        elseif IS_PRACTICE then
            -- continue
        else
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                -- continue
            else
                if not finishLine or typeof(finishLine) ~= "Instance" then
                    -- continue
                else
                    local distance
                    pcall(function()
                        distance = (hrp.Position - finishLine.Position).Magnitude
                    end)

                    if not distance or distance > 10 then
                        -- continue
                    else
                        local possessor = findPossessor()
                        if not possessor then
                            -- continue
                        else
                            local possessorIsLocalPlayer = possessor == character
                            if possessorIsLocalPlayer then
                                local event = game:GetService("ReplicatedStorage").Remotes.Touchdown
                                if event then
                                    event:FireServer()
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)
